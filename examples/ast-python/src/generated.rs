# ! [allow (clippy)] # ! [allow (unused)] # ! [allow (dead_code)] # ! [allow (non_camel_case_types)] # ! [allow (non_snake_case)] # [derive (Debug , Clone , PartialEq)] pub struct AliasedImport { pub name : std :: sync :: Arc < DottedName > , pub alias : std :: sync :: Arc < Identifier > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for AliasedImport { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl AliasedImport { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 117u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for AliasedImport { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let name = node . children_by_field_id (std :: num :: NonZero :: new (19u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (name) , }) ? ; let name = std :: sync :: Arc :: new (DottedName :: try_from ((& name , & mut * index)) ?) ; index . push (name . clone () as _) ; ; let alias = node . children_by_field_id (std :: num :: NonZero :: new (1u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (alias) , }) ? ; let alias = std :: sync :: Arc :: new (Identifier :: try_from ((& alias , & mut * index)) ?) ; index . push (alias . clone () as _) ; ; Ok (Self { name , alias , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ArgumentList { pub children : Vec < std :: sync :: Arc < DictionarySplat_Expression_KeywordArgument_ListSplat_ParenthesizedExpression >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ArgumentList { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ArgumentList { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 158u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ArgumentList { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | DictionarySplat_Expression_KeywordArgument_ListSplat_ParenthesizedExpression :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (DictionarySplat_Expression_KeywordArgument_ListSplat_ParenthesizedExpression :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct AsPattern { pub alias : Option < std :: sync :: Arc < AsPatternTarget >> , pub children : Vec < std :: sync :: Arc < CasePattern_Expression_Identifier >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for AsPattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl AsPattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 186u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for AsPattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let alias = node . children_by_field_id (std :: num :: NonZero :: new (1u16) . unwrap () , & mut cursor) . next () . map (| node | { let alias = std :: sync :: Arc :: new (AsPatternTarget :: try_from ((& node , & mut * index)) ?) ; index . push (alias . clone () as _) ; Ok (alias) }) . transpose () ? ; ; let children = node . named_children (& mut cursor) . filter (| n | CasePattern_Expression_Identifier :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (CasePattern_Expression_Identifier :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { alias , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct AssertStatement { pub children : Vec < std :: sync :: Arc < Expression >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for AssertStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl AssertStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 121u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for AssertStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Expression :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Expression :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Assignment { pub left : std :: sync :: Arc < Pattern_PatternList > , pub right : Option < std :: sync :: Arc < Assignment_AugmentedAssignment_Expression_ExpressionList_PatternList_Yield >> , pub Type : Option < std :: sync :: Arc < Type >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Assignment { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Assignment { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 199u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Assignment { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let left = node . children_by_field_id (std :: num :: NonZero :: new (17u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (left) , }) ? ; let left = std :: sync :: Arc :: new (Pattern_PatternList :: try_from ((& left , & mut * index)) ?) ; index . push (left . clone () as _) ; ; let right = node . children_by_field_id (std :: num :: NonZero :: new (25u16) . unwrap () , & mut cursor) . next () . map (| node | { let right = std :: sync :: Arc :: new (Assignment_AugmentedAssignment_Expression_ExpressionList_PatternList_Yield :: try_from ((& node , & mut * index)) ?) ; index . push (right . clone () as _) ; Ok (right) }) . transpose () ? ; ; let Type = node . children_by_field_id (std :: num :: NonZero :: new (29u16) . unwrap () , & mut cursor) . next () . map (| node | { let Type = std :: sync :: Arc :: new (Type :: try_from ((& node , & mut * index)) ?) ; index . push (Type . clone () as _) ; Ok (Type) }) . transpose () ? ; ; Ok (Self { left , right , Type , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Attribute { pub attribute : std :: sync :: Arc < Identifier > , pub object : std :: sync :: Arc < PrimaryExpression > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Attribute { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Attribute { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 204u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Attribute { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let attribute = node . children_by_field_id (std :: num :: NonZero :: new (5u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (attribute) , }) ? ; let attribute = std :: sync :: Arc :: new (Identifier :: try_from ((& attribute , & mut * index)) ?) ; index . push (attribute . clone () as _) ; ; let object = node . children_by_field_id (std :: num :: NonZero :: new (20u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (object) , }) ? ; let object = std :: sync :: Arc :: new (PrimaryExpression :: try_from ((& object , & mut * index)) ?) ; index . push (object . clone () as _) ; ; Ok (Self { attribute , object , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct AugmentedAssignment { pub left : std :: sync :: Arc < Pattern_PatternList > , pub operator : std :: sync :: Arc < Operators_0 > , pub right : std :: sync :: Arc < Assignment_AugmentedAssignment_Expression_ExpressionList_PatternList_Yield > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for AugmentedAssignment { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl AugmentedAssignment { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 200u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for AugmentedAssignment { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let left = node . children_by_field_id (std :: num :: NonZero :: new (17u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (left) , }) ? ; let left = std :: sync :: Arc :: new (Pattern_PatternList :: try_from ((& left , & mut * index)) ?) ; index . push (left . clone () as _) ; ; let operator = node . children_by_field_id (std :: num :: NonZero :: new (21u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (operator) , }) ? ; let operator = std :: sync :: Arc :: new (Operators_0 :: try_from ((& operator , & mut * index)) ?) ; index . push (operator . clone () as _) ; ; let right = node . children_by_field_id (std :: num :: NonZero :: new (25u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (right) , }) ? ; let right = std :: sync :: Arc :: new (Assignment_AugmentedAssignment_Expression_ExpressionList_PatternList_Yield :: try_from ((& right , & mut * index)) ?) ; index . push (right . clone () as _) ; ; Ok (Self { left , operator , right , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Await { pub children : std :: sync :: Arc < PrimaryExpression > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Await { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Await { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 238u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Await { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | PrimaryExpression :: contains (n)) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (PrimaryExpression) , }) ? ; let children = std :: sync :: Arc :: new (PrimaryExpression :: try_from ((& children , & mut * index)) ?) ; index . push (children . clone () as _) ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct BinaryOperator { pub right : std :: sync :: Arc < PrimaryExpression > , pub left : std :: sync :: Arc < PrimaryExpression > , pub operator : std :: sync :: Arc < Operators_1 > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for BinaryOperator { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl BinaryOperator { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 192u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for BinaryOperator { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let right = node . children_by_field_id (std :: num :: NonZero :: new (25u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (right) , }) ? ; let right = std :: sync :: Arc :: new (PrimaryExpression :: try_from ((& right , & mut * index)) ?) ; index . push (right . clone () as _) ; ; let left = node . children_by_field_id (std :: num :: NonZero :: new (17u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (left) , }) ? ; let left = std :: sync :: Arc :: new (PrimaryExpression :: try_from ((& left , & mut * index)) ?) ; index . push (left . clone () as _) ; ; let operator = node . children_by_field_id (std :: num :: NonZero :: new (21u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (operator) , }) ? ; let operator = std :: sync :: Arc :: new (Operators_1 :: try_from ((& operator , & mut * index)) ?) ; index . push (operator . clone () as _) ; ; Ok (Self { right , left , operator , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Block { pub alternative : Vec < std :: sync :: Arc < CaseClause >> , pub children : Vec < std :: sync :: Arc < CompoundStatement_SimpleStatement >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Block { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Block { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 161u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Block { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let alternative = node . children_by_field_id (std :: num :: NonZero :: new (2u16) . unwrap () , & mut cursor) . map (| node | { let result = std :: sync :: Arc :: new (CaseClause :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; let children = node . named_children (& mut cursor) . filter (| n | CompoundStatement_SimpleStatement :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (CompoundStatement_SimpleStatement :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { alternative , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct BooleanOperator { pub operator : std :: sync :: Arc < Operators_2 > , pub right : std :: sync :: Arc < Expression > , pub left : std :: sync :: Arc < Expression > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for BooleanOperator { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl BooleanOperator { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 191u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for BooleanOperator { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let operator = node . children_by_field_id (std :: num :: NonZero :: new (21u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (operator) , }) ? ; let operator = std :: sync :: Arc :: new (Operators_2 :: try_from ((& operator , & mut * index)) ?) ; index . push (operator . clone () as _) ; ; let right = node . children_by_field_id (std :: num :: NonZero :: new (25u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (right) , }) ? ; let right = std :: sync :: Arc :: new (Expression :: try_from ((& right , & mut * index)) ?) ; index . push (right . clone () as _) ; ; let left = node . children_by_field_id (std :: num :: NonZero :: new (17u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (left) , }) ? ; let left = std :: sync :: Arc :: new (Expression :: try_from ((& left , & mut * index)) ?) ; index . push (left . clone () as _) ; ; Ok (Self { operator , right , left , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct BreakStatement { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for BreakStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl BreakStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 129u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for BreakStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Call { pub function : std :: sync :: Arc < PrimaryExpression > , pub arguments : std :: sync :: Arc < ArgumentList_GeneratorExpression > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Call { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Call { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 207u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Call { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let function = node . children_by_field_id (std :: num :: NonZero :: new (14u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (function) , }) ? ; let function = std :: sync :: Arc :: new (PrimaryExpression :: try_from ((& function , & mut * index)) ?) ; index . push (function . clone () as _) ; ; let arguments = node . children_by_field_id (std :: num :: NonZero :: new (4u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (arguments) , }) ? ; let arguments = std :: sync :: Arc :: new (ArgumentList_GeneratorExpression :: try_from ((& arguments , & mut * index)) ?) ; index . push (arguments . clone () as _) ; ; Ok (Self { function , arguments , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct CaseClause { pub guard : Option < std :: sync :: Arc < IfClause >> , pub consequence : std :: sync :: Arc < Block > , pub children : Vec < std :: sync :: Arc < CasePattern >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for CaseClause { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl CaseClause { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 136u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for CaseClause { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let guard = node . children_by_field_id (std :: num :: NonZero :: new (15u16) . unwrap () , & mut cursor) . next () . map (| node | { let guard = std :: sync :: Arc :: new (IfClause :: try_from ((& node , & mut * index)) ?) ; index . push (guard . clone () as _) ; Ok (guard) }) . transpose () ? ; ; let consequence = node . children_by_field_id (std :: num :: NonZero :: new (10u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (consequence) , }) ? ; let consequence = std :: sync :: Arc :: new (Block :: try_from ((& consequence , & mut * index)) ?) ; index . push (consequence . clone () as _) ; ; let children = node . named_children (& mut cursor) . filter (| n | CasePattern :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (CasePattern :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { guard , consequence , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct CasePattern { pub children : Option < std :: sync :: Arc < AsPattern_ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_KeywordPattern_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for CasePattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl CasePattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 164u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for CasePattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | AsPattern_ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_KeywordPattern_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern :: contains (n)) . next () . map (| node | { let result = std :: sync :: Arc :: new (AsPattern_ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_KeywordPattern_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . transpose () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Chevron { pub children : std :: sync :: Arc < Expression > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Chevron { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Chevron { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 120u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Chevron { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Expression :: contains (n)) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Expression) , }) ? ; let children = std :: sync :: Arc :: new (Expression :: try_from ((& children , & mut * index)) ?) ; index . push (children . clone () as _) ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ClassDefinition { pub type_parameters : Option < std :: sync :: Arc < TypeParameter >> , pub superclasses : Option < std :: sync :: Arc < ArgumentList >> , pub body : std :: sync :: Arc < Block > , pub name : std :: sync :: Arc < Identifier > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ClassDefinition { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ClassDefinition { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 155u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ClassDefinition { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let type_parameters = node . children_by_field_id (std :: num :: NonZero :: new (31u16) . unwrap () , & mut cursor) . next () . map (| node | { let type_parameters = std :: sync :: Arc :: new (TypeParameter :: try_from ((& node , & mut * index)) ?) ; index . push (type_parameters . clone () as _) ; Ok (type_parameters) }) . transpose () ? ; ; let superclasses = node . children_by_field_id (std :: num :: NonZero :: new (28u16) . unwrap () , & mut cursor) . next () . map (| node | { let superclasses = std :: sync :: Arc :: new (ArgumentList :: try_from ((& node , & mut * index)) ?) ; index . push (superclasses . clone () as _) ; Ok (superclasses) }) . transpose () ? ; ; let body = node . children_by_field_id (std :: num :: NonZero :: new (6u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (body) , }) ? ; let body = std :: sync :: Arc :: new (Block :: try_from ((& body , & mut * index)) ?) ; index . push (body . clone () as _) ; ; let name = node . children_by_field_id (std :: num :: NonZero :: new (19u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (name) , }) ? ; let name = std :: sync :: Arc :: new (Identifier :: try_from ((& name , & mut * index)) ?) ; index . push (name . clone () as _) ; ; Ok (Self { type_parameters , superclasses , body , name , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ClassPattern { pub children : Vec < std :: sync :: Arc < CasePattern_DottedName >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ClassPattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ClassPattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 174u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ClassPattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | CasePattern_DottedName :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (CasePattern_DottedName :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ComparisonOperator { pub operators : Vec < std :: sync :: Arc < Operators_3 >> , pub children : Vec < std :: sync :: Arc < PrimaryExpression >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ComparisonOperator { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ComparisonOperator { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 196u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ComparisonOperator { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let operators = node . children_by_field_id (std :: num :: NonZero :: new (22u16) . unwrap () , & mut cursor) . map (| node | { let result = std :: sync :: Arc :: new (Operators_3 :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; let children = node . named_children (& mut cursor) . filter (| n | PrimaryExpression :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (PrimaryExpression :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { operators , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ComplexPattern { pub children : Vec < std :: sync :: Arc < Float_Integer >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ComplexPattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ComplexPattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 175u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ComplexPattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Float_Integer :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Float_Integer :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ConcatenatedString { pub children : Vec < std :: sync :: Arc < String >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ConcatenatedString { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ConcatenatedString { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 231u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ConcatenatedString { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | String :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (String :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ConditionalExpression { pub children : Vec < std :: sync :: Arc < Expression >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ConditionalExpression { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ConditionalExpression { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 230u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ConditionalExpression { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Expression :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Expression :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ConstrainedType { pub children : Vec < std :: sync :: Arc < Type >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ConstrainedType { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ConstrainedType { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 213u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ConstrainedType { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Type :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Type :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ContinueStatement { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ContinueStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ContinueStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 130u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ContinueStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct DecoratedDefinition { pub definition : std :: sync :: Arc < ClassDefinition_FunctionDefinition > , pub children : Vec < std :: sync :: Arc < Decorator >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for DecoratedDefinition { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl DecoratedDefinition { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 159u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for DecoratedDefinition { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let definition = node . children_by_field_id (std :: num :: NonZero :: new (11u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (definition) , }) ? ; let definition = std :: sync :: Arc :: new (ClassDefinition_FunctionDefinition :: try_from ((& definition , & mut * index)) ?) ; index . push (definition . clone () as _) ; ; let children = node . named_children (& mut cursor) . filter (| n | Decorator :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Decorator :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { definition , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Decorator { pub children : std :: sync :: Arc < Expression > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Decorator { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Decorator { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 160u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Decorator { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Expression :: contains (n)) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Expression) , }) ? ; let children = std :: sync :: Arc :: new (Expression :: try_from ((& children , & mut * index)) ?) ; index . push (children . clone () as _) ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct DefaultParameter { pub value : std :: sync :: Arc < Expression > , pub name : std :: sync :: Arc < Identifier_TuplePattern > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for DefaultParameter { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl DefaultParameter { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 182u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for DefaultParameter { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let value = node . children_by_field_id (std :: num :: NonZero :: new (32u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (value) , }) ? ; let value = std :: sync :: Arc :: new (Expression :: try_from ((& value , & mut * index)) ?) ; index . push (value . clone () as _) ; ; let name = node . children_by_field_id (std :: num :: NonZero :: new (19u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (name) , }) ? ; let name = std :: sync :: Arc :: new (Identifier_TuplePattern :: try_from ((& name , & mut * index)) ?) ; index . push (name . clone () as _) ; ; Ok (Self { value , name , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct DeleteStatement { pub children : std :: sync :: Arc < Expression_ExpressionList > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for DeleteStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl DeleteStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 126u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for DeleteStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Expression_ExpressionList :: contains (n)) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Expression_ExpressionList) , }) ? ; let children = std :: sync :: Arc :: new (Expression_ExpressionList :: try_from ((& children , & mut * index)) ?) ; index . push (children . clone () as _) ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct DictPattern { pub value : Vec < std :: sync :: Arc < CasePattern >> , pub key : Vec < std :: sync :: Arc < Minus_Underscore_ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern >> , pub children : Vec < std :: sync :: Arc < SplatPattern >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for DictPattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl DictPattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 170u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for DictPattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let value = node . children_by_field_id (std :: num :: NonZero :: new (32u16) . unwrap () , & mut cursor) . map (| node | { let result = std :: sync :: Arc :: new (CasePattern :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; let key = node . children_by_field_id (std :: num :: NonZero :: new (16u16) . unwrap () , & mut cursor) . map (| node | { let result = std :: sync :: Arc :: new (Minus_Underscore_ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; let children = node . named_children (& mut cursor) . filter (| n | SplatPattern :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (SplatPattern :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { value , key , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Dictionary { pub children : Vec < std :: sync :: Arc < DictionarySplat_Pair >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Dictionary { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Dictionary { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 219u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Dictionary { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | DictionarySplat_Pair :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (DictionarySplat_Pair :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct DictionaryComprehension { pub body : std :: sync :: Arc < Pair > , pub children : Vec < std :: sync :: Arc < ForInClause_IfClause >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for DictionaryComprehension { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl DictionaryComprehension { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 222u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for DictionaryComprehension { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let body = node . children_by_field_id (std :: num :: NonZero :: new (6u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (body) , }) ? ; let body = std :: sync :: Arc :: new (Pair :: try_from ((& body , & mut * index)) ?) ; index . push (body . clone () as _) ; ; let children = node . named_children (& mut cursor) . filter (| n | ForInClause_IfClause :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (ForInClause_IfClause :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { body , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct DictionarySplat { pub children : std :: sync :: Arc < Expression > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for DictionarySplat { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl DictionarySplat { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 150u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for DictionarySplat { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Expression :: contains (n)) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Expression) , }) ? ; let children = std :: sync :: Arc :: new (Expression :: try_from ((& children , & mut * index)) ?) ; index . push (children . clone () as _) ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct DictionarySplatPattern { pub children : std :: sync :: Arc < Attribute_Identifier_Subscript > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for DictionarySplatPattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl DictionarySplatPattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 185u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for DictionarySplatPattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Attribute_Identifier_Subscript :: contains (n)) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Attribute_Identifier_Subscript) , }) ? ; let children = std :: sync :: Arc :: new (Attribute_Identifier_Subscript :: try_from ((& children , & mut * index)) ?) ; index . push (children . clone () as _) ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct DottedName { pub children : Vec < std :: sync :: Arc < Identifier >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for DottedName { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl DottedName { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 163u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for DottedName { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Identifier :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Identifier :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ElifClause { pub consequence : std :: sync :: Arc < Block > , pub condition : std :: sync :: Arc < Expression > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ElifClause { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ElifClause { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 132u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ElifClause { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let consequence = node . children_by_field_id (std :: num :: NonZero :: new (10u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (consequence) , }) ? ; let consequence = std :: sync :: Arc :: new (Block :: try_from ((& consequence , & mut * index)) ?) ; index . push (consequence . clone () as _) ; ; let condition = node . children_by_field_id (std :: num :: NonZero :: new (9u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (condition) , }) ? ; let condition = std :: sync :: Arc :: new (Expression :: try_from ((& condition , & mut * index)) ?) ; index . push (condition . clone () as _) ; ; Ok (Self { consequence , condition , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ElseClause { pub body : std :: sync :: Arc < Block > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ElseClause { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ElseClause { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 133u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ElseClause { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let body = node . children_by_field_id (std :: num :: NonZero :: new (6u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (body) , }) ? ; let body = std :: sync :: Arc :: new (Block :: try_from ((& body , & mut * index)) ?) ; index . push (body . clone () as _) ; ; Ok (Self { body , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ExceptClause { pub value : Option < std :: sync :: Arc < Expression >> , pub alias : Option < std :: sync :: Arc < Expression >> , pub children : std :: sync :: Arc < Block > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ExceptClause { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ExceptClause { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 140u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ExceptClause { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let value = node . children_by_field_id (std :: num :: NonZero :: new (32u16) . unwrap () , & mut cursor) . next () . map (| node | { let value = std :: sync :: Arc :: new (Expression :: try_from ((& node , & mut * index)) ?) ; index . push (value . clone () as _) ; Ok (value) }) . transpose () ? ; ; let alias = node . children_by_field_id (std :: num :: NonZero :: new (1u16) . unwrap () , & mut cursor) . next () . map (| node | { let alias = std :: sync :: Arc :: new (Expression :: try_from ((& node , & mut * index)) ?) ; index . push (alias . clone () as _) ; Ok (alias) }) . transpose () ? ; ; let children = node . named_children (& mut cursor) . filter (| n | Block :: contains (n)) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Block) , }) ? ; let children = std :: sync :: Arc :: new (Block :: try_from ((& children , & mut * index)) ?) ; index . push (children . clone () as _) ; ; Ok (Self { value , alias , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ExceptGroupClause { pub children : Vec < std :: sync :: Arc < Block_Expression >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ExceptGroupClause { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ExceptGroupClause { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 141u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ExceptGroupClause { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Block_Expression :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Block_Expression :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ExecStatement { pub code : std :: sync :: Arc < Identifier_String > , pub children : Vec < std :: sync :: Arc < Expression >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ExecStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ExecStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 153u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ExecStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let code = node . children_by_field_id (std :: num :: NonZero :: new (8u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (code) , }) ? ; let code = std :: sync :: Arc :: new (Identifier_String :: try_from ((& code , & mut * index)) ?) ; index . push (code . clone () as _) ; ; let children = node . named_children (& mut cursor) . filter (| n | Expression :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Expression :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { code , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ExpressionList { pub children : Vec < std :: sync :: Arc < Expression >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ExpressionList { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ExpressionList { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 162u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ExpressionList { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Expression :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Expression :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ExpressionStatement { pub children : Vec < std :: sync :: Arc < Assignment_AugmentedAssignment_Expression_Yield >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ExpressionStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ExpressionStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 122u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ExpressionStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Assignment_AugmentedAssignment_Expression_Yield :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Assignment_AugmentedAssignment_Expression_Yield :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct FinallyClause { pub children : std :: sync :: Arc < Block > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for FinallyClause { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl FinallyClause { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 142u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for FinallyClause { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Block :: contains (n)) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Block) , }) ? ; let children = std :: sync :: Arc :: new (Block :: try_from ((& children , & mut * index)) ?) ; index . push (children . clone () as _) ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ForInClause { pub right : Vec < std :: sync :: Arc < Comma_Expression >> , pub left : std :: sync :: Arc < Pattern_PatternList > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ForInClause { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ForInClause { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 228u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ForInClause { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let right = node . children_by_field_id (std :: num :: NonZero :: new (25u16) . unwrap () , & mut cursor) . map (| node | { let result = std :: sync :: Arc :: new (Comma_Expression :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; let left = node . children_by_field_id (std :: num :: NonZero :: new (17u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (left) , }) ? ; let left = std :: sync :: Arc :: new (Pattern_PatternList :: try_from ((& left , & mut * index)) ?) ; index . push (left . clone () as _) ; ; Ok (Self { right , left , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ForStatement { pub alternative : Option < std :: sync :: Arc < ElseClause >> , pub body : std :: sync :: Arc < Block > , pub left : std :: sync :: Arc < Pattern_PatternList > , pub right : std :: sync :: Arc < Expression_ExpressionList > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ForStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ForStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 137u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ForStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let alternative = node . children_by_field_id (std :: num :: NonZero :: new (2u16) . unwrap () , & mut cursor) . next () . map (| node | { let alternative = std :: sync :: Arc :: new (ElseClause :: try_from ((& node , & mut * index)) ?) ; index . push (alternative . clone () as _) ; Ok (alternative) }) . transpose () ? ; ; let body = node . children_by_field_id (std :: num :: NonZero :: new (6u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (body) , }) ? ; let body = std :: sync :: Arc :: new (Block :: try_from ((& body , & mut * index)) ?) ; index . push (body . clone () as _) ; ; let left = node . children_by_field_id (std :: num :: NonZero :: new (17u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (left) , }) ? ; let left = std :: sync :: Arc :: new (Pattern_PatternList :: try_from ((& left , & mut * index)) ?) ; index . push (left . clone () as _) ; ; let right = node . children_by_field_id (std :: num :: NonZero :: new (25u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (right) , }) ? ; let right = std :: sync :: Arc :: new (Expression_ExpressionList :: try_from ((& right , & mut * index)) ?) ; index . push (right . clone () as _) ; ; Ok (Self { alternative , body , left , right , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct FormatExpression { pub type_conversion : Option < std :: sync :: Arc < TypeConversion >> , pub expression : std :: sync :: Arc < Expression_ExpressionList_PatternList_Yield > , pub format_specifier : Option < std :: sync :: Arc < FormatSpecifier >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for FormatExpression { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl FormatExpression { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 274u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for FormatExpression { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let type_conversion = node . children_by_field_id (std :: num :: NonZero :: new (30u16) . unwrap () , & mut cursor) . next () . map (| node | { let type_conversion = std :: sync :: Arc :: new (TypeConversion :: try_from ((& node , & mut * index)) ?) ; index . push (type_conversion . clone () as _) ; Ok (type_conversion) }) . transpose () ? ; ; let expression = node . children_by_field_id (std :: num :: NonZero :: new (12u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (expression) , }) ? ; let expression = std :: sync :: Arc :: new (Expression_ExpressionList_PatternList_Yield :: try_from ((& expression , & mut * index)) ?) ; index . push (expression . clone () as _) ; ; let format_specifier = node . children_by_field_id (std :: num :: NonZero :: new (13u16) . unwrap () , & mut cursor) . next () . map (| node | { let format_specifier = std :: sync :: Arc :: new (FormatSpecifier :: try_from ((& node , & mut * index)) ?) ; index . push (format_specifier . clone () as _) ; Ok (format_specifier) }) . transpose () ? ; ; Ok (Self { type_conversion , expression , format_specifier , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct FormatSpecifier { pub children : Vec < std :: sync :: Arc < FormatExpression >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for FormatSpecifier { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl FormatSpecifier { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 237u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for FormatSpecifier { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | FormatExpression :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (FormatExpression :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct FunctionDefinition { pub body : std :: sync :: Arc < Block > , pub name : std :: sync :: Arc < Identifier > , pub parameters : std :: sync :: Arc < Parameters > , pub type_parameters : Option < std :: sync :: Arc < TypeParameter >> , pub return_type : Option < std :: sync :: Arc < Type >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for FunctionDefinition { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl FunctionDefinition { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 146u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for FunctionDefinition { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let body = node . children_by_field_id (std :: num :: NonZero :: new (6u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (body) , }) ? ; let body = std :: sync :: Arc :: new (Block :: try_from ((& body , & mut * index)) ?) ; index . push (body . clone () as _) ; ; let name = node . children_by_field_id (std :: num :: NonZero :: new (19u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (name) , }) ? ; let name = std :: sync :: Arc :: new (Identifier :: try_from ((& name , & mut * index)) ?) ; index . push (name . clone () as _) ; ; let parameters = node . children_by_field_id (std :: num :: NonZero :: new (23u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (parameters) , }) ? ; let parameters = std :: sync :: Arc :: new (Parameters :: try_from ((& parameters , & mut * index)) ?) ; index . push (parameters . clone () as _) ; ; let type_parameters = node . children_by_field_id (std :: num :: NonZero :: new (31u16) . unwrap () , & mut cursor) . next () . map (| node | { let type_parameters = std :: sync :: Arc :: new (TypeParameter :: try_from ((& node , & mut * index)) ?) ; index . push (type_parameters . clone () as _) ; Ok (type_parameters) }) . transpose () ? ; ; let return_type = node . children_by_field_id (std :: num :: NonZero :: new (24u16) . unwrap () , & mut cursor) . next () . map (| node | { let return_type = std :: sync :: Arc :: new (Type :: try_from ((& node , & mut * index)) ?) ; index . push (return_type . clone () as _) ; Ok (return_type) }) . transpose () ? ; ; Ok (Self { body , name , parameters , type_parameters , return_type , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct FutureImportStatement { pub name : Vec < std :: sync :: Arc < AliasedImport_DottedName >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for FutureImportStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl FutureImportStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 114u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for FutureImportStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let name = node . children_by_field_id (std :: num :: NonZero :: new (19u16) . unwrap () , & mut cursor) . map (| node | { let result = std :: sync :: Arc :: new (AliasedImport_DottedName :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { name , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct GeneratorExpression { pub body : std :: sync :: Arc < Expression > , pub children : Vec < std :: sync :: Arc < ForInClause_IfClause >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for GeneratorExpression { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl GeneratorExpression { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 224u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for GeneratorExpression { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let body = node . children_by_field_id (std :: num :: NonZero :: new (6u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (body) , }) ? ; let body = std :: sync :: Arc :: new (Expression :: try_from ((& body , & mut * index)) ?) ; index . push (body . clone () as _) ; ; let children = node . named_children (& mut cursor) . filter (| n | ForInClause_IfClause :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (ForInClause_IfClause :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { body , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct GenericType { pub children : Vec < std :: sync :: Arc < Identifier_TypeParameter >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for GenericType { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl GenericType { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 211u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for GenericType { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Identifier_TypeParameter :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Identifier_TypeParameter :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct GlobalStatement { pub children : Vec < std :: sync :: Arc < Identifier >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for GlobalStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl GlobalStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 151u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for GlobalStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Identifier :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Identifier :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct IfClause { pub children : std :: sync :: Arc < Expression > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for IfClause { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl IfClause { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 229u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for IfClause { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Expression :: contains (n)) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Expression) , }) ? ; let children = std :: sync :: Arc :: new (Expression :: try_from ((& children , & mut * index)) ?) ; index . push (children . clone () as _) ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct IfStatement { pub alternative : Vec < std :: sync :: Arc < ElifClause_ElseClause >> , pub condition : std :: sync :: Arc < Expression > , pub consequence : std :: sync :: Arc < Block > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for IfStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl IfStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 131u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for IfStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let alternative = node . children_by_field_id (std :: num :: NonZero :: new (2u16) . unwrap () , & mut cursor) . map (| node | { let result = std :: sync :: Arc :: new (ElifClause_ElseClause :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; let condition = node . children_by_field_id (std :: num :: NonZero :: new (9u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (condition) , }) ? ; let condition = std :: sync :: Arc :: new (Expression :: try_from ((& condition , & mut * index)) ?) ; index . push (condition . clone () as _) ; ; let consequence = node . children_by_field_id (std :: num :: NonZero :: new (10u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (consequence) , }) ? ; let consequence = std :: sync :: Arc :: new (Block :: try_from ((& consequence , & mut * index)) ?) ; index . push (consequence . clone () as _) ; ; Ok (Self { alternative , condition , consequence , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ImportFromStatement { pub module_name : std :: sync :: Arc < DottedName_RelativeImport > , pub name : Vec < std :: sync :: Arc < AliasedImport_DottedName >> , pub children : Option < std :: sync :: Arc < WildcardImport >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ImportFromStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ImportFromStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 115u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ImportFromStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let module_name = node . children_by_field_id (std :: num :: NonZero :: new (18u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (module_name) , }) ? ; let module_name = std :: sync :: Arc :: new (DottedName_RelativeImport :: try_from ((& module_name , & mut * index)) ?) ; index . push (module_name . clone () as _) ; ; let name = node . children_by_field_id (std :: num :: NonZero :: new (19u16) . unwrap () , & mut cursor) . map (| node | { let result = std :: sync :: Arc :: new (AliasedImport_DottedName :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; let children = node . named_children (& mut cursor) . filter (| n | WildcardImport :: contains (n)) . next () . map (| node | { let result = std :: sync :: Arc :: new (WildcardImport :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . transpose () ? ; ; Ok (Self { module_name , name , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ImportPrefix { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ImportPrefix { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ImportPrefix { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 112u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ImportPrefix { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct ImportStatement { pub name : Vec < std :: sync :: Arc < AliasedImport_DottedName >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ImportStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ImportStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 111u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ImportStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let name = node . children_by_field_id (std :: num :: NonZero :: new (19u16) . unwrap () , & mut cursor) . map (| node | { let result = std :: sync :: Arc :: new (AliasedImport_DottedName :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { name , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Interpolation { pub type_conversion : Option < std :: sync :: Arc < TypeConversion >> , pub expression : std :: sync :: Arc < Expression_ExpressionList_PatternList_Yield > , pub format_specifier : Option < std :: sync :: Arc < FormatSpecifier >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Interpolation { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Interpolation { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 234u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Interpolation { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let type_conversion = node . children_by_field_id (std :: num :: NonZero :: new (30u16) . unwrap () , & mut cursor) . next () . map (| node | { let type_conversion = std :: sync :: Arc :: new (TypeConversion :: try_from ((& node , & mut * index)) ?) ; index . push (type_conversion . clone () as _) ; Ok (type_conversion) }) . transpose () ? ; ; let expression = node . children_by_field_id (std :: num :: NonZero :: new (12u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (expression) , }) ? ; let expression = std :: sync :: Arc :: new (Expression_ExpressionList_PatternList_Yield :: try_from ((& expression , & mut * index)) ?) ; index . push (expression . clone () as _) ; ; let format_specifier = node . children_by_field_id (std :: num :: NonZero :: new (13u16) . unwrap () , & mut cursor) . next () . map (| node | { let format_specifier = std :: sync :: Arc :: new (FormatSpecifier :: try_from ((& node , & mut * index)) ?) ; index . push (format_specifier . clone () as _) ; Ok (format_specifier) }) . transpose () ? ; ; Ok (Self { type_conversion , expression , format_specifier , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_IsNot { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_IsNot { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_IsNot { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "is not") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_IsNot { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct KeywordArgument { pub name : std :: sync :: Arc < Identifier > , pub value : std :: sync :: Arc < Expression > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for KeywordArgument { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl KeywordArgument { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 215u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for KeywordArgument { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let name = node . children_by_field_id (std :: num :: NonZero :: new (19u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (name) , }) ? ; let name = std :: sync :: Arc :: new (Identifier :: try_from ((& name , & mut * index)) ?) ; index . push (name . clone () as _) ; ; let value = node . children_by_field_id (std :: num :: NonZero :: new (32u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (value) , }) ? ; let value = std :: sync :: Arc :: new (Expression :: try_from ((& value , & mut * index)) ?) ; index . push (value . clone () as _) ; ; Ok (Self { name , value , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct KeywordPattern { pub children : Vec < std :: sync :: Arc < ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Identifier_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for KeywordPattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl KeywordPattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 172u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for KeywordPattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Identifier_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Identifier_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct KeywordSeparator { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for KeywordSeparator { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl KeywordSeparator { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 240u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for KeywordSeparator { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Lambda { pub body : std :: sync :: Arc < Expression > , pub parameters : Option < std :: sync :: Arc < LambdaParameters >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Lambda { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Lambda { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 197u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Lambda { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let body = node . children_by_field_id (std :: num :: NonZero :: new (6u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (body) , }) ? ; let body = std :: sync :: Arc :: new (Expression :: try_from ((& body , & mut * index)) ?) ; index . push (body . clone () as _) ; ; let parameters = node . children_by_field_id (std :: num :: NonZero :: new (23u16) . unwrap () , & mut cursor) . next () . map (| node | { let parameters = std :: sync :: Arc :: new (LambdaParameters :: try_from ((& node , & mut * index)) ?) ; index . push (parameters . clone () as _) ; Ok (parameters) }) . transpose () ? ; ; Ok (Self { body , parameters , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct LambdaParameters { pub children : Vec < std :: sync :: Arc < Parameter >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for LambdaParameters { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl LambdaParameters { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 148u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for LambdaParameters { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Parameter :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Parameter :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct List { pub children : Vec < std :: sync :: Arc < Expression_ListSplat_ParenthesizedListSplat_Yield >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for List { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl List { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 216u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for List { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Expression_ListSplat_ParenthesizedListSplat_Yield :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Expression_ListSplat_ParenthesizedListSplat_Yield :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ListComprehension { pub body : std :: sync :: Arc < Expression > , pub children : Vec < std :: sync :: Arc < ForInClause_IfClause >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ListComprehension { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ListComprehension { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 221u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ListComprehension { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let body = node . children_by_field_id (std :: num :: NonZero :: new (6u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (body) , }) ? ; let body = std :: sync :: Arc :: new (Expression :: try_from ((& body , & mut * index)) ?) ; index . push (body . clone () as _) ; ; let children = node . named_children (& mut cursor) . filter (| n | ForInClause_IfClause :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (ForInClause_IfClause :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { body , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ListPattern { pub children : Vec < std :: sync :: Arc < CasePattern_Pattern >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ListPattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ListPattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 181u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ListPattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | CasePattern_Pattern :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (CasePattern_Pattern :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ListSplat { pub children : std :: sync :: Arc < Attribute_Expression_Identifier_Subscript > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ListSplat { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ListSplat { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 149u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ListSplat { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Attribute_Expression_Identifier_Subscript :: contains (n)) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Attribute_Expression_Identifier_Subscript) , }) ? ; let children = std :: sync :: Arc :: new (Attribute_Expression_Identifier_Subscript :: try_from ((& children , & mut * index)) ?) ; index . push (children . clone () as _) ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ListSplatPattern { pub children : std :: sync :: Arc < Attribute_Identifier_Subscript > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ListSplatPattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ListSplatPattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 184u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ListSplatPattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Attribute_Identifier_Subscript :: contains (n)) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Attribute_Identifier_Subscript) , }) ? ; let children = std :: sync :: Arc :: new (Attribute_Identifier_Subscript :: try_from ((& children , & mut * index)) ?) ; index . push (children . clone () as _) ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct MatchStatement { pub subject : Vec < std :: sync :: Arc < Expression >> , pub body : std :: sync :: Arc < Block > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for MatchStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl MatchStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 134u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for MatchStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let subject = node . children_by_field_id (std :: num :: NonZero :: new (26u16) . unwrap () , & mut cursor) . map (| node | { let result = std :: sync :: Arc :: new (Expression :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; let body = node . children_by_field_id (std :: num :: NonZero :: new (6u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (body) , }) ? ; let body = std :: sync :: Arc :: new (Block :: try_from ((& body , & mut * index)) ?) ; index . push (body . clone () as _) ; ; Ok (Self { subject , body , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct MemberType { pub children : Vec < std :: sync :: Arc < Identifier_Type >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for MemberType { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl MemberType { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 214u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for MemberType { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Identifier_Type :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Identifier_Type :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Module { pub children : Vec < std :: sync :: Arc < CompoundStatement_SimpleStatement >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Module { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Module { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 108u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Module { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | CompoundStatement_SimpleStatement :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (CompoundStatement_SimpleStatement :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct NamedExpression { pub name : std :: sync :: Arc < Identifier > , pub value : std :: sync :: Arc < Expression > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for NamedExpression { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl NamedExpression { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 123u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for NamedExpression { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let name = node . children_by_field_id (std :: num :: NonZero :: new (19u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (name) , }) ? ; let name = std :: sync :: Arc :: new (Identifier :: try_from ((& name , & mut * index)) ?) ; index . push (name . clone () as _) ; ; let value = node . children_by_field_id (std :: num :: NonZero :: new (32u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (value) , }) ? ; let value = std :: sync :: Arc :: new (Expression :: try_from ((& value , & mut * index)) ?) ; index . push (value . clone () as _) ; ; Ok (Self { name , value , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct NonlocalStatement { pub children : Vec < std :: sync :: Arc < Identifier >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for NonlocalStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl NonlocalStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 152u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for NonlocalStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Identifier :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Identifier :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_NotIn { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_NotIn { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_NotIn { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "not in") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_NotIn { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct NotOperator { pub argument : std :: sync :: Arc < Expression > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for NotOperator { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl NotOperator { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 190u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for NotOperator { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let argument = node . children_by_field_id (std :: num :: NonZero :: new (3u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (argument) , }) ? ; let argument = std :: sync :: Arc :: new (Expression :: try_from ((& argument , & mut * index)) ?) ; index . push (argument . clone () as _) ; ; Ok (Self { argument , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Pair { pub key : std :: sync :: Arc < Expression > , pub value : std :: sync :: Arc < Expression > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Pair { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Pair { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 220u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Pair { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let key = node . children_by_field_id (std :: num :: NonZero :: new (16u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (key) , }) ? ; let key = std :: sync :: Arc :: new (Expression :: try_from ((& key , & mut * index)) ?) ; index . push (key . clone () as _) ; ; let value = node . children_by_field_id (std :: num :: NonZero :: new (32u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (value) , }) ? ; let value = std :: sync :: Arc :: new (Expression :: try_from ((& value , & mut * index)) ?) ; index . push (value . clone () as _) ; ; Ok (Self { key , value , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Parameters { pub children : Vec < std :: sync :: Arc < Parameter >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Parameters { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Parameters { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 147u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Parameters { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Parameter :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Parameter :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ParenthesizedExpression { pub children : std :: sync :: Arc < Expression_ListSplat_ParenthesizedExpression_Yield > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ParenthesizedExpression { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ParenthesizedExpression { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 226u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ParenthesizedExpression { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Expression_ListSplat_ParenthesizedExpression_Yield :: contains (n)) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Expression_ListSplat_ParenthesizedExpression_Yield) , }) ? ; let children = std :: sync :: Arc :: new (Expression_ListSplat_ParenthesizedExpression_Yield :: try_from ((& children , & mut * index)) ?) ; index . push (children . clone () as _) ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ParenthesizedListSplat { pub children : std :: sync :: Arc < ListSplat_ParenthesizedExpression > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ParenthesizedListSplat { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ParenthesizedListSplat { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 157u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ParenthesizedListSplat { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | ListSplat_ParenthesizedExpression :: contains (n)) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (ListSplat_ParenthesizedExpression) , }) ? ; let children = std :: sync :: Arc :: new (ListSplat_ParenthesizedExpression :: try_from ((& children , & mut * index)) ?) ; index . push (children . clone () as _) ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct PassStatement { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for PassStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl PassStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 128u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for PassStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct PatternList { pub children : Vec < std :: sync :: Arc < Pattern >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for PatternList { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl PatternList { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 201u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for PatternList { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Pattern :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Pattern :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct PositionalSeparator { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for PositionalSeparator { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl PositionalSeparator { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 239u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for PositionalSeparator { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct PrintStatement { pub argument : Vec < std :: sync :: Arc < Expression >> , pub children : Option < std :: sync :: Arc < Chevron >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for PrintStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl PrintStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 119u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for PrintStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let argument = node . children_by_field_id (std :: num :: NonZero :: new (3u16) . unwrap () , & mut cursor) . map (| node | { let result = std :: sync :: Arc :: new (Expression :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; let children = node . named_children (& mut cursor) . filter (| n | Chevron :: contains (n)) . next () . map (| node | { let result = std :: sync :: Arc :: new (Chevron :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . transpose () ? ; ; Ok (Self { argument , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct RaiseStatement { pub cause : Option < std :: sync :: Arc < Expression >> , pub children : Option < std :: sync :: Arc < Expression_ExpressionList >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for RaiseStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl RaiseStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 127u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for RaiseStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let cause = node . children_by_field_id (std :: num :: NonZero :: new (7u16) . unwrap () , & mut cursor) . next () . map (| node | { let cause = std :: sync :: Arc :: new (Expression :: try_from ((& node , & mut * index)) ?) ; index . push (cause . clone () as _) ; Ok (cause) }) . transpose () ? ; ; let children = node . named_children (& mut cursor) . filter (| n | Expression_ExpressionList :: contains (n)) . next () . map (| node | { let result = std :: sync :: Arc :: new (Expression_ExpressionList :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . transpose () ? ; ; Ok (Self { cause , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct RelativeImport { pub children : Vec < std :: sync :: Arc < DottedName_ImportPrefix >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for RelativeImport { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl RelativeImport { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 113u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for RelativeImport { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | DottedName_ImportPrefix :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (DottedName_ImportPrefix :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct ReturnStatement { pub children : Option < std :: sync :: Arc < Expression_ExpressionList >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for ReturnStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl ReturnStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 125u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ReturnStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Expression_ExpressionList :: contains (n)) . next () . map (| node | { let result = std :: sync :: Arc :: new (Expression_ExpressionList :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . transpose () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Set { pub children : Vec < std :: sync :: Arc < Expression_ListSplat_ParenthesizedListSplat_Yield >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Set { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Set { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 217u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Set { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Expression_ListSplat_ParenthesizedListSplat_Yield :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Expression_ListSplat_ParenthesizedListSplat_Yield :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct SetComprehension { pub body : std :: sync :: Arc < Expression > , pub children : Vec < std :: sync :: Arc < ForInClause_IfClause >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for SetComprehension { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl SetComprehension { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 223u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for SetComprehension { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let body = node . children_by_field_id (std :: num :: NonZero :: new (6u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (body) , }) ? ; let body = std :: sync :: Arc :: new (Expression :: try_from ((& body , & mut * index)) ?) ; index . push (body . clone () as _) ; ; let children = node . named_children (& mut cursor) . filter (| n | ForInClause_IfClause :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (ForInClause_IfClause :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { body , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Slice { pub children : Vec < std :: sync :: Arc < Expression >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Slice { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Slice { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 206u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Slice { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Expression :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Expression :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct SplatPattern { pub children : Option < std :: sync :: Arc < Identifier >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for SplatPattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl SplatPattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 173u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for SplatPattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Identifier :: contains (n)) . next () . map (| node | { let result = std :: sync :: Arc :: new (Identifier :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . transpose () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct SplatType { pub children : std :: sync :: Arc < Identifier > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for SplatType { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl SplatType { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 210u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for SplatType { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Identifier :: contains (n)) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Identifier) , }) ? ; let children = std :: sync :: Arc :: new (Identifier :: try_from ((& children , & mut * index)) ?) ; index . push (children . clone () as _) ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct String { pub children : Vec < std :: sync :: Arc < Interpolation_StringContent_StringEnd_StringStart >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for String { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl String { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 232u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for String { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Interpolation_StringContent_StringEnd_StringStart :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Interpolation_StringContent_StringEnd_StringStart :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct StringContent { pub children : Vec < std :: sync :: Arc < EscapeInterpolation_EscapeSequence >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for StringContent { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl StringContent { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 233u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for StringContent { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | EscapeInterpolation_EscapeSequence :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (EscapeInterpolation_EscapeSequence :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Subscript { pub subscript : Vec < std :: sync :: Arc < Expression_Slice >> , pub value : std :: sync :: Arc < PrimaryExpression > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Subscript { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Subscript { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 205u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Subscript { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let subscript = node . children_by_field_id (std :: num :: NonZero :: new (27u16) . unwrap () , & mut cursor) . map (| node | { let result = std :: sync :: Arc :: new (Expression_Slice :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; let value = node . children_by_field_id (std :: num :: NonZero :: new (32u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (value) , }) ? ; let value = std :: sync :: Arc :: new (PrimaryExpression :: try_from ((& value , & mut * index)) ?) ; index . push (value . clone () as _) ; ; Ok (Self { subscript , value , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct TryStatement { pub body : std :: sync :: Arc < Block > , pub children : Vec < std :: sync :: Arc < ElseClause_ExceptClause_ExceptGroupClause_FinallyClause >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for TryStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl TryStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 139u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for TryStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let body = node . children_by_field_id (std :: num :: NonZero :: new (6u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (body) , }) ? ; let body = std :: sync :: Arc :: new (Block :: try_from ((& body , & mut * index)) ?) ; index . push (body . clone () as _) ; ; let children = node . named_children (& mut cursor) . filter (| n | ElseClause_ExceptClause_ExceptGroupClause_FinallyClause :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (ElseClause_ExceptClause_ExceptGroupClause_FinallyClause :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { body , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Tuple { pub children : Vec < std :: sync :: Arc < Expression_ListSplat_ParenthesizedListSplat_Yield >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Tuple { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Tuple { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 218u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Tuple { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Expression_ListSplat_ParenthesizedListSplat_Yield :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Expression_ListSplat_ParenthesizedListSplat_Yield :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct TuplePattern { pub children : Vec < std :: sync :: Arc < CasePattern_Pattern >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for TuplePattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl TuplePattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 180u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for TuplePattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | CasePattern_Pattern :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (CasePattern_Pattern :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Type { pub children : std :: sync :: Arc < ConstrainedType_Expression_GenericType_MemberType_SplatType_UnionType > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Type { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Type { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 209u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Type { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | ConstrainedType_Expression_GenericType_MemberType_SplatType_UnionType :: contains (n)) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (ConstrainedType_Expression_GenericType_MemberType_SplatType_UnionType) , }) ? ; let children = std :: sync :: Arc :: new (ConstrainedType_Expression_GenericType_MemberType_SplatType_UnionType :: try_from ((& children , & mut * index)) ?) ; index . push (children . clone () as _) ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct TypeAliasStatement { pub right : std :: sync :: Arc < Type > , pub left : std :: sync :: Arc < Type > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for TypeAliasStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl TypeAliasStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 154u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for TypeAliasStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let right = node . children_by_field_id (std :: num :: NonZero :: new (25u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (right) , }) ? ; let right = std :: sync :: Arc :: new (Type :: try_from ((& right , & mut * index)) ?) ; index . push (right . clone () as _) ; ; let left = node . children_by_field_id (std :: num :: NonZero :: new (17u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (left) , }) ? ; let left = std :: sync :: Arc :: new (Type :: try_from ((& left , & mut * index)) ?) ; index . push (left . clone () as _) ; ; Ok (Self { right , left , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct TypeParameter { pub children : Vec < std :: sync :: Arc < Type >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for TypeParameter { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl TypeParameter { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 156u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for TypeParameter { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Type :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Type :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct TypedDefaultParameter { pub name : std :: sync :: Arc < Identifier > , pub value : std :: sync :: Arc < Expression > , pub Type : std :: sync :: Arc < Type > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for TypedDefaultParameter { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl TypedDefaultParameter { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 183u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for TypedDefaultParameter { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let name = node . children_by_field_id (std :: num :: NonZero :: new (19u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (name) , }) ? ; let name = std :: sync :: Arc :: new (Identifier :: try_from ((& name , & mut * index)) ?) ; index . push (name . clone () as _) ; ; let value = node . children_by_field_id (std :: num :: NonZero :: new (32u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (value) , }) ? ; let value = std :: sync :: Arc :: new (Expression :: try_from ((& value , & mut * index)) ?) ; index . push (value . clone () as _) ; ; let Type = node . children_by_field_id (std :: num :: NonZero :: new (29u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Type) , }) ? ; let Type = std :: sync :: Arc :: new (Type :: try_from ((& Type , & mut * index)) ?) ; index . push (Type . clone () as _) ; ; Ok (Self { name , value , Type , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct TypedParameter { pub Type : std :: sync :: Arc < Type > , pub children : std :: sync :: Arc < DictionarySplatPattern_Identifier_ListSplatPattern > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for TypedParameter { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl TypedParameter { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 208u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for TypedParameter { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let Type = node . children_by_field_id (std :: num :: NonZero :: new (29u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Type) , }) ? ; let Type = std :: sync :: Arc :: new (Type :: try_from ((& Type , & mut * index)) ?) ; index . push (Type . clone () as _) ; ; let children = node . named_children (& mut cursor) . filter (| n | DictionarySplatPattern_Identifier_ListSplatPattern :: contains (n)) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (DictionarySplatPattern_Identifier_ListSplatPattern) , }) ? ; let children = std :: sync :: Arc :: new (DictionarySplatPattern_Identifier_ListSplatPattern :: try_from ((& children , & mut * index)) ?) ; index . push (children . clone () as _) ; ; Ok (Self { Type , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct UnaryOperator { pub operator : std :: sync :: Arc < Operators_4 > , pub argument : std :: sync :: Arc < PrimaryExpression > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for UnaryOperator { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl UnaryOperator { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 193u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for UnaryOperator { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let operator = node . children_by_field_id (std :: num :: NonZero :: new (21u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (operator) , }) ? ; let operator = std :: sync :: Arc :: new (Operators_4 :: try_from ((& operator , & mut * index)) ?) ; index . push (operator . clone () as _) ; ; let argument = node . children_by_field_id (std :: num :: NonZero :: new (3u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (argument) , }) ? ; let argument = std :: sync :: Arc :: new (PrimaryExpression :: try_from ((& argument , & mut * index)) ?) ; index . push (argument . clone () as _) ; ; Ok (Self { operator , argument , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct UnionPattern { pub children : Vec < std :: sync :: Arc < ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for UnionPattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl UnionPattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 167u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for UnionPattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct UnionType { pub children : Vec < std :: sync :: Arc < Type >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for UnionType { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl UnionType { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 212u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for UnionType { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Type :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (Type :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct WhileStatement { pub condition : std :: sync :: Arc < Expression > , pub alternative : Option < std :: sync :: Arc < ElseClause >> , pub body : std :: sync :: Arc < Block > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for WhileStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl WhileStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 138u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for WhileStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let condition = node . children_by_field_id (std :: num :: NonZero :: new (9u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (condition) , }) ? ; let condition = std :: sync :: Arc :: new (Expression :: try_from ((& condition , & mut * index)) ?) ; index . push (condition . clone () as _) ; ; let alternative = node . children_by_field_id (std :: num :: NonZero :: new (2u16) . unwrap () , & mut cursor) . next () . map (| node | { let alternative = std :: sync :: Arc :: new (ElseClause :: try_from ((& node , & mut * index)) ?) ; index . push (alternative . clone () as _) ; Ok (alternative) }) . transpose () ? ; ; let body = node . children_by_field_id (std :: num :: NonZero :: new (6u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (body) , }) ? ; let body = std :: sync :: Arc :: new (Block :: try_from ((& body , & mut * index)) ?) ; index . push (body . clone () as _) ; ; Ok (Self { condition , alternative , body , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct WildcardImport { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for WildcardImport { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl WildcardImport { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 118u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for WildcardImport { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct WithClause { pub children : Vec < std :: sync :: Arc < WithItem >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for WithClause { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl WithClause { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 144u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for WithClause { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | WithItem :: contains (n)) . map (| node | { let result = std :: sync :: Arc :: new (WithItem :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . collect :: < Result < Vec < _ > , Self :: Error >> () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct WithItem { pub value : std :: sync :: Arc < Expression > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for WithItem { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl WithItem { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 145u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for WithItem { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let value = node . children_by_field_id (std :: num :: NonZero :: new (32u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (value) , }) ? ; let value = std :: sync :: Arc :: new (Expression :: try_from ((& value , & mut * index)) ?) ; index . push (value . clone () as _) ; ; Ok (Self { value , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct WithStatement { pub body : std :: sync :: Arc < Block > , pub children : std :: sync :: Arc < WithClause > , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for WithStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl WithStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 143u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for WithStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let body = node . children_by_field_id (std :: num :: NonZero :: new (6u16) . unwrap () , & mut cursor) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (body) , }) ? ; let body = std :: sync :: Arc :: new (Block :: try_from ((& body , & mut * index)) ?) ; index . push (body . clone () as _) ; ; let children = node . named_children (& mut cursor) . filter (| n | WithClause :: contains (n)) . next () . ok_or_else (|| auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (WithClause) , }) ? ; let children = std :: sync :: Arc :: new (WithClause :: try_from ((& children , & mut * index)) ?) ; index . push (children . clone () as _) ; ; Ok (Self { body , children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Yield { pub children : Option < std :: sync :: Arc < Expression_ExpressionList >> , _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Yield { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Yield { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 203u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Yield { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { let mut cursor = node . walk () ; let children = node . named_children (& mut cursor) . filter (| n | Expression_ExpressionList :: contains (n)) . next () . map (| node | { let result = std :: sync :: Arc :: new (Expression_ExpressionList :: try_from ((& node , & mut * index)) ?) ; index . push (result . clone () as _) ; Ok (result) }) . transpose () ? ; ; Ok (Self { children , _range : node . range () , }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_NotEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_NotEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_NotEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "!=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_NotEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Percent { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Percent { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Percent { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "%") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Percent { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_PercentEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_PercentEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_PercentEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "%=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_PercentEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Ampersand { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Ampersand { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Ampersand { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "&") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Ampersand { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_AmpersandEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_AmpersandEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_AmpersandEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "&=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_AmpersandEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_LeftParen { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_LeftParen { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_LeftParen { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "(") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_LeftParen { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_RightParen { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_RightParen { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_RightParen { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , ")") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_RightParen { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Star { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Star { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Star { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "*") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Star { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_StarStar { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_StarStar { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_StarStar { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "**") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_StarStar { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_StarStarEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_StarStarEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_StarStarEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "**=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_StarStarEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_StarEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_StarEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_StarEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "*=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_StarEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Plus { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Plus { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Plus { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "+") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Plus { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_PlusEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_PlusEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_PlusEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "+=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_PlusEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Comma { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Comma { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Comma { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , ",") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Comma { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Minus { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Minus { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Minus { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "-") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Minus { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_MinusEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_MinusEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_MinusEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "-=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_MinusEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Arrow { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Arrow { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Arrow { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "->") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Arrow { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Dot { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Dot { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Dot { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , ".") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Dot { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Slash { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Slash { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Slash { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "/") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Slash { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_SlashSlash { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_SlashSlash { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_SlashSlash { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "//") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_SlashSlash { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_SlashSlashEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_SlashSlashEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_SlashSlashEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "//=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_SlashSlashEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_SlashEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_SlashEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_SlashEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "/=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_SlashEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Colon { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Colon { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Colon { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , ":") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Colon { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_ColonEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_ColonEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_ColonEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , ":=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_ColonEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Semicolon { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Semicolon { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Semicolon { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , ";") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Semicolon { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Less { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Less { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Less { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "<") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Less { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_ShiftLeft { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_ShiftLeft { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_ShiftLeft { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "<<") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_ShiftLeft { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_LessLessEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_LessLessEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_LessLessEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "<<=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_LessLessEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_LessEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_LessEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_LessEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "<=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_LessEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_LessGreater { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_LessGreater { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_LessGreater { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "<>") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_LessGreater { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Equal { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Equal { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Equal { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Equal { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_EqualEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_EqualEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_EqualEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "==") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_EqualEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Greater { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Greater { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Greater { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , ">") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Greater { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_GreaterEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_GreaterEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_GreaterEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , ">=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_GreaterEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_ShiftRight { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_ShiftRight { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_ShiftRight { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , ">>") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_ShiftRight { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_GreaterGreaterEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_GreaterGreaterEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_GreaterGreaterEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , ">>=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_GreaterGreaterEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_At { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_At { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_At { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "@") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_At { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_AtEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_AtEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_AtEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "@=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_AtEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_LeftBracket { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_LeftBracket { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_LeftBracket { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "[") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_LeftBracket { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Backslash { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Backslash { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Backslash { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "\\") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Backslash { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_RightBracket { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_RightBracket { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_RightBracket { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "]") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_RightBracket { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Caret { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Caret { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Caret { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "^") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Caret { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_CaretEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_CaretEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_CaretEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "^=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_CaretEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Underscore { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Underscore { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Underscore { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "_") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Underscore { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Future { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Future { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Future { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "__future__") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Future { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_And { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_And { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_And { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "and") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_And { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_As { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_As { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_As { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "as") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_As { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Assert { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Assert { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Assert { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "assert") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Assert { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Async { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Async { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Async { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "async") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Async { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Await { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Await { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Await { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 238u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Await { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Break { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Break { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Break { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "break") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Break { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Case { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Case { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Case { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "case") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Case { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Class { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Class { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Class { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "class") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Class { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Comment { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Comment { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Comment { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 99u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Comment { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Continue { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Continue { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Continue { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "continue") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Continue { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Def { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Def { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Def { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "def") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Def { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Del { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Del { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Del { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "del") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Del { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Elif { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Elif { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Elif { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "elif") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Elif { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Ellipsis { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Ellipsis { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Ellipsis { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 88u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Ellipsis { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Else { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Else { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Else { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "else") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Else { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct EscapeInterpolation { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for EscapeInterpolation { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl EscapeInterpolation { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 106u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for EscapeInterpolation { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct EscapeSequence { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for EscapeSequence { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl EscapeSequence { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 89u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for EscapeSequence { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Except { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Except { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Except { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "except") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Except { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_ExceptStar { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_ExceptStar { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_ExceptStar { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "except*") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_ExceptStar { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Exec { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Exec { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Exec { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "exec") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Exec { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct False { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for False { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl False { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 97u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for False { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Finally { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Finally { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Finally { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "finally") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Finally { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Float { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Float { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Float { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 94u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Float { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_For { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_For { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_For { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "for") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_For { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_From { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_From { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_From { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "from") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_From { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Global { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Global { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Global { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "global") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Global { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Identifier { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Identifier { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Identifier { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 1u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Identifier { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_If { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_If { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_If { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "if") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_If { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Import { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Import { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Import { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "import") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Import { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_In { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_In { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_In { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "in") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_In { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Integer { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Integer { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Integer { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 93u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Integer { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Is { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Is { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Is { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "is") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Is { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Lambda { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Lambda { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Lambda { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 197u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Lambda { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct LineContinuation { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for LineContinuation { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl LineContinuation { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 100u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for LineContinuation { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Match { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Match { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Match { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "match") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Match { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct None { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for None { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl None { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 98u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for None { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Nonlocal { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Nonlocal { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Nonlocal { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "nonlocal") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Nonlocal { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Not { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Not { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Not { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "not") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Not { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Or { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Or { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Or { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "or") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Or { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Pass { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Pass { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Pass { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "pass") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Pass { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Print { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Print { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Print { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "print") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Print { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Raise { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Raise { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Raise { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "raise") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Raise { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Return { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Return { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Return { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "return") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Return { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct StringEnd { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for StringEnd { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl StringEnd { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 107u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for StringEnd { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct StringStart { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for StringStart { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl StringStart { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 104u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for StringStart { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct True { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for True { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl True { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 96u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for True { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Try { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Try { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Try { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "try") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Try { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Type { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Type { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Type { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 209u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Type { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct TypeConversion { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for TypeConversion { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl TypeConversion { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 92u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for TypeConversion { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_While { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_While { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_While { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "while") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_While { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_With { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_With { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_With { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "with") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_With { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Yield { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Yield { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Yield { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 203u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Yield { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_LeftCurly { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_LeftCurly { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_LeftCurly { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "{") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_LeftCurly { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Pipe { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Pipe { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Pipe { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "|") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Pipe { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_PipeEqual { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_PipeEqual { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_PipeEqual { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "|=") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_PipeEqual { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_RightCurly { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_RightCurly { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_RightCurly { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "}") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_RightCurly { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub struct Token_Tilde { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for Token_Tilde { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl Token_Tilde { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "~") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Token_Tilde { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub enum Operators_1 { Token_Percent (Token_Percent) , Token_Ampersand (Token_Ampersand) , Token_Star (Token_Star) , Token_StarStar (Token_StarStar) , Token_Plus (Token_Plus) , Token_Minus (Token_Minus) , Token_Slash (Token_Slash) , Token_SlashSlash (Token_SlashSlash) , Token_ShiftLeft (Token_ShiftLeft) , Token_ShiftRight (Token_ShiftRight) , Token_At (Token_At) , Token_Caret (Token_Caret) , Token_Pipe (Token_Pipe) } impl auto_lsp :: core :: ast :: AstNode for Operators_1 { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Token_Percent (node) => node . get_range () , Self :: Token_Ampersand (node) => node . get_range () , Self :: Token_Star (node) => node . get_range () , Self :: Token_StarStar (node) => node . get_range () , Self :: Token_Plus (node) => node . get_range () , Self :: Token_Minus (node) => node . get_range () , Self :: Token_Slash (node) => node . get_range () , Self :: Token_SlashSlash (node) => node . get_range () , Self :: Token_ShiftLeft (node) => node . get_range () , Self :: Token_ShiftRight (node) => node . get_range () , Self :: Token_At (node) => node . get_range () , Self :: Token_Caret (node) => node . get_range () , Self :: Token_Pipe (node) => node . get_range () } } } impl Operators_1 { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 59u16 | 61u16 | 11u16 | 39u16 | 54u16 | 49u16 | 58u16 | 60u16 | 63u16 | 13u16 | 48u16 | 62u16 | 51u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Operators_1 { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 59u16 => Ok (Self :: Token_Percent (Token_Percent :: try_from ((node , & mut * index)) ?)) , 61u16 => Ok (Self :: Token_Ampersand (Token_Ampersand :: try_from ((node , & mut * index)) ?)) , 11u16 => Ok (Self :: Token_Star (Token_Star :: try_from ((node , & mut * index)) ?)) , 39u16 => Ok (Self :: Token_StarStar (Token_StarStar :: try_from ((node , & mut * index)) ?)) , 54u16 => Ok (Self :: Token_Plus (Token_Plus :: try_from ((node , & mut * index)) ?)) , 49u16 => Ok (Self :: Token_Minus (Token_Minus :: try_from ((node , & mut * index)) ?)) , 58u16 => Ok (Self :: Token_Slash (Token_Slash :: try_from ((node , & mut * index)) ?)) , 60u16 => Ok (Self :: Token_SlashSlash (Token_SlashSlash :: try_from ((node , & mut * index)) ?)) , 63u16 => Ok (Self :: Token_ShiftLeft (Token_ShiftLeft :: try_from ((node , & mut * index)) ?)) , 13u16 => Ok (Self :: Token_ShiftRight (Token_ShiftRight :: try_from ((node , & mut * index)) ?)) , 48u16 => Ok (Self :: Token_At (Token_At :: try_from ((node , & mut * index)) ?)) , 62u16 => Ok (Self :: Token_Caret (Token_Caret :: try_from ((node , & mut * index)) ?)) , 51u16 => Ok (Self :: Token_Pipe (Token_Pipe :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Operators_1) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Operators_0 { Token_PercentEqual (Token_PercentEqual) , Token_AmpersandEqual (Token_AmpersandEqual) , Token_StarStarEqual (Token_StarStarEqual) , Token_StarEqual (Token_StarEqual) , Token_PlusEqual (Token_PlusEqual) , Token_MinusEqual (Token_MinusEqual) , Token_SlashSlashEqual (Token_SlashSlashEqual) , Token_SlashEqual (Token_SlashEqual) , Token_LessLessEqual (Token_LessLessEqual) , Token_GreaterGreaterEqual (Token_GreaterGreaterEqual) , Token_AtEqual (Token_AtEqual) , Token_CaretEqual (Token_CaretEqual) , Token_PipeEqual (Token_PipeEqual) } impl auto_lsp :: core :: ast :: AstNode for Operators_0 { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Token_PercentEqual (node) => node . get_range () , Self :: Token_AmpersandEqual (node) => node . get_range () , Self :: Token_StarStarEqual (node) => node . get_range () , Self :: Token_StarEqual (node) => node . get_range () , Self :: Token_PlusEqual (node) => node . get_range () , Self :: Token_MinusEqual (node) => node . get_range () , Self :: Token_SlashSlashEqual (node) => node . get_range () , Self :: Token_SlashEqual (node) => node . get_range () , Self :: Token_LessLessEqual (node) => node . get_range () , Self :: Token_GreaterGreaterEqual (node) => node . get_range () , Self :: Token_AtEqual (node) => node . get_range () , Self :: Token_CaretEqual (node) => node . get_range () , Self :: Token_PipeEqual (node) => node . get_range () } } } impl Operators_0 { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 80u16 | 84u16 | 81u16 | 76u16 | 74u16 | 75u16 | 79u16 | 77u16 | 83u16 | 82u16 | 78u16 | 85u16 | 86u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Operators_0 { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 80u16 => Ok (Self :: Token_PercentEqual (Token_PercentEqual :: try_from ((node , & mut * index)) ?)) , 84u16 => Ok (Self :: Token_AmpersandEqual (Token_AmpersandEqual :: try_from ((node , & mut * index)) ?)) , 81u16 => Ok (Self :: Token_StarStarEqual (Token_StarStarEqual :: try_from ((node , & mut * index)) ?)) , 76u16 => Ok (Self :: Token_StarEqual (Token_StarEqual :: try_from ((node , & mut * index)) ?)) , 74u16 => Ok (Self :: Token_PlusEqual (Token_PlusEqual :: try_from ((node , & mut * index)) ?)) , 75u16 => Ok (Self :: Token_MinusEqual (Token_MinusEqual :: try_from ((node , & mut * index)) ?)) , 79u16 => Ok (Self :: Token_SlashSlashEqual (Token_SlashSlashEqual :: try_from ((node , & mut * index)) ?)) , 77u16 => Ok (Self :: Token_SlashEqual (Token_SlashEqual :: try_from ((node , & mut * index)) ?)) , 83u16 => Ok (Self :: Token_LessLessEqual (Token_LessLessEqual :: try_from ((node , & mut * index)) ?)) , 82u16 => Ok (Self :: Token_GreaterGreaterEqual (Token_GreaterGreaterEqual :: try_from ((node , & mut * index)) ?)) , 78u16 => Ok (Self :: Token_AtEqual (Token_AtEqual :: try_from ((node , & mut * index)) ?)) , 85u16 => Ok (Self :: Token_CaretEqual (Token_CaretEqual :: try_from ((node , & mut * index)) ?)) , 86u16 => Ok (Self :: Token_PipeEqual (Token_PipeEqual :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Operators_0) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Operators_2 { Token_And (Token_And) , Token_Or (Token_Or) } impl auto_lsp :: core :: ast :: AstNode for Operators_2 { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Token_And (node) => node . get_range () , Self :: Token_Or (node) => node . get_range () } } } impl Operators_2 { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 56u16 | 57u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Operators_2 { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 56u16 => Ok (Self :: Token_And (Token_And :: try_from ((node , & mut * index)) ?)) , 57u16 => Ok (Self :: Token_Or (Token_Or :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Operators_2) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Operators_4 { Token_Plus (Token_Plus) , Token_Minus (Token_Minus) , Token_Tilde (Token_Tilde) } impl auto_lsp :: core :: ast :: AstNode for Operators_4 { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Token_Plus (node) => node . get_range () , Self :: Token_Minus (node) => node . get_range () , Self :: Token_Tilde (node) => node . get_range () } } } impl Operators_4 { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 54u16 | 49u16 | 64u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Operators_4 { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 54u16 => Ok (Self :: Token_Plus (Token_Plus :: try_from ((node , & mut * index)) ?)) , 49u16 => Ok (Self :: Token_Minus (Token_Minus :: try_from ((node , & mut * index)) ?)) , 64u16 => Ok (Self :: Token_Tilde (Token_Tilde :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Operators_4) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Operators_3 { Token_NotEqual (Token_NotEqual) , Token_Less (Token_Less) , Token_LessEqual (Token_LessEqual) , Token_LessGreater (Token_LessGreater) , Token_EqualEqual (Token_EqualEqual) , Token_Greater (Token_Greater) , Token_GreaterEqual (Token_GreaterEqual) , Token_In (Token_In) , Token_Is (Token_Is) , Token_IsNot (Token_IsNot) , Token_NotIn (Token_NotIn) } impl auto_lsp :: core :: ast :: AstNode for Operators_3 { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Token_NotEqual (node) => node . get_range () , Self :: Token_Less (node) => node . get_range () , Self :: Token_LessEqual (node) => node . get_range () , Self :: Token_LessGreater (node) => node . get_range () , Self :: Token_EqualEqual (node) => node . get_range () , Self :: Token_Greater (node) => node . get_range () , Self :: Token_GreaterEqual (node) => node . get_range () , Self :: Token_In (node) => node . get_range () , Self :: Token_Is (node) => node . get_range () , Self :: Token_IsNot (node) => node . get_range () , Self :: Token_NotIn (node) => node . get_range () } } } impl Operators_3 { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 69u16 | 66u16 | 67u16 | 72u16 | 68u16 | 71u16 | 70u16 | 30u16 | 65u16 | 195u16 | 194u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Operators_3 { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 69u16 => Ok (Self :: Token_NotEqual (Token_NotEqual :: try_from ((node , & mut * index)) ?)) , 66u16 => Ok (Self :: Token_Less (Token_Less :: try_from ((node , & mut * index)) ?)) , 67u16 => Ok (Self :: Token_LessEqual (Token_LessEqual :: try_from ((node , & mut * index)) ?)) , 72u16 => Ok (Self :: Token_LessGreater (Token_LessGreater :: try_from ((node , & mut * index)) ?)) , 68u16 => Ok (Self :: Token_EqualEqual (Token_EqualEqual :: try_from ((node , & mut * index)) ?)) , 71u16 => Ok (Self :: Token_Greater (Token_Greater :: try_from ((node , & mut * index)) ?)) , 70u16 => Ok (Self :: Token_GreaterEqual (Token_GreaterEqual :: try_from ((node , & mut * index)) ?)) , 30u16 => Ok (Self :: Token_In (Token_In :: try_from ((node , & mut * index)) ?)) , 65u16 => Ok (Self :: Token_Is (Token_Is :: try_from ((node , & mut * index)) ?)) , 195u16 => Ok (Self :: Token_IsNot (Token_IsNot :: try_from ((node , & mut * index)) ?)) , 194u16 => Ok (Self :: Token_NotIn (Token_NotIn :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Operators_3) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Attribute_Identifier_Subscript { Attribute (Attribute) , Identifier (Identifier) , Subscript (Subscript) } impl auto_lsp :: core :: ast :: AstNode for Attribute_Identifier_Subscript { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Attribute (node) => node . get_range () , Self :: Identifier (node) => node . get_range () , Self :: Subscript (node) => node . get_range () } } } impl Attribute_Identifier_Subscript { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 204u16 | 1u16 | 205u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Attribute_Identifier_Subscript { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 204u16 => Ok (Self :: Attribute (Attribute :: try_from ((node , & mut * index)) ?)) , 1u16 => Ok (Self :: Identifier (Identifier :: try_from ((node , & mut * index)) ?)) , 205u16 => Ok (Self :: Subscript (Subscript :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Attribute_Identifier_Subscript) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum ClassDefinition_FunctionDefinition { ClassDefinition (ClassDefinition) , FunctionDefinition (FunctionDefinition) } impl auto_lsp :: core :: ast :: AstNode for ClassDefinition_FunctionDefinition { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: ClassDefinition (node) => node . get_range () , Self :: FunctionDefinition (node) => node . get_range () } } } impl ClassDefinition_FunctionDefinition { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 155u16 | 146u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ClassDefinition_FunctionDefinition { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 155u16 => Ok (Self :: ClassDefinition (ClassDefinition :: try_from ((node , & mut * index)) ?)) , 146u16 => Ok (Self :: FunctionDefinition (FunctionDefinition :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (ClassDefinition_FunctionDefinition) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Minus_Underscore_ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern { Token_Minus (Token_Minus) , Token_Underscore (Token_Underscore) , ClassPattern (ClassPattern) , ComplexPattern (ComplexPattern) , ConcatenatedString (ConcatenatedString) , DictPattern (DictPattern) , DottedName (DottedName) , False (False) , Float (Float) , Integer (Integer) , ListPattern (ListPattern) , None (None) , SplatPattern (SplatPattern) , String (String) , True (True) , TuplePattern (TuplePattern) , UnionPattern (UnionPattern) } impl auto_lsp :: core :: ast :: AstNode for Minus_Underscore_ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Token_Minus (node) => node . get_range () , Self :: Token_Underscore (node) => node . get_range () , Self :: ClassPattern (node) => node . get_range () , Self :: ComplexPattern (node) => node . get_range () , Self :: ConcatenatedString (node) => node . get_range () , Self :: DictPattern (node) => node . get_range () , Self :: DottedName (node) => node . get_range () , Self :: False (node) => node . get_range () , Self :: Float (node) => node . get_range () , Self :: Integer (node) => node . get_range () , Self :: ListPattern (node) => node . get_range () , Self :: None (node) => node . get_range () , Self :: SplatPattern (node) => node . get_range () , Self :: String (node) => node . get_range () , Self :: True (node) => node . get_range () , Self :: TuplePattern (node) => node . get_range () , Self :: UnionPattern (node) => node . get_range () } } } impl Minus_Underscore_ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 49u16 | 50u16 | 174u16 | 175u16 | 231u16 | 170u16 | 163u16 | 97u16 | 94u16 | 93u16 | 181u16 | 98u16 | 173u16 | 232u16 | 96u16 | 180u16 | 167u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Minus_Underscore_ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 49u16 => Ok (Self :: Token_Minus (Token_Minus :: try_from ((node , & mut * index)) ?)) , 50u16 => Ok (Self :: Token_Underscore (Token_Underscore :: try_from ((node , & mut * index)) ?)) , 174u16 => Ok (Self :: ClassPattern (ClassPattern :: try_from ((node , & mut * index)) ?)) , 175u16 => Ok (Self :: ComplexPattern (ComplexPattern :: try_from ((node , & mut * index)) ?)) , 231u16 => Ok (Self :: ConcatenatedString (ConcatenatedString :: try_from ((node , & mut * index)) ?)) , 170u16 => Ok (Self :: DictPattern (DictPattern :: try_from ((node , & mut * index)) ?)) , 163u16 => Ok (Self :: DottedName (DottedName :: try_from ((node , & mut * index)) ?)) , 97u16 => Ok (Self :: False (False :: try_from ((node , & mut * index)) ?)) , 94u16 => Ok (Self :: Float (Float :: try_from ((node , & mut * index)) ?)) , 93u16 => Ok (Self :: Integer (Integer :: try_from ((node , & mut * index)) ?)) , 181u16 => Ok (Self :: ListPattern (ListPattern :: try_from ((node , & mut * index)) ?)) , 98u16 => Ok (Self :: None (None :: try_from ((node , & mut * index)) ?)) , 173u16 => Ok (Self :: SplatPattern (SplatPattern :: try_from ((node , & mut * index)) ?)) , 232u16 => Ok (Self :: String (String :: try_from ((node , & mut * index)) ?)) , 96u16 => Ok (Self :: True (True :: try_from ((node , & mut * index)) ?)) , 180u16 => Ok (Self :: TuplePattern (TuplePattern :: try_from ((node , & mut * index)) ?)) , 167u16 => Ok (Self :: UnionPattern (UnionPattern :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Minus_Underscore_ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern { ClassPattern (ClassPattern) , ComplexPattern (ComplexPattern) , ConcatenatedString (ConcatenatedString) , DictPattern (DictPattern) , DottedName (DottedName) , False (False) , Float (Float) , Integer (Integer) , ListPattern (ListPattern) , None (None) , SplatPattern (SplatPattern) , String (String) , True (True) , TuplePattern (TuplePattern) , UnionPattern (UnionPattern) } impl auto_lsp :: core :: ast :: AstNode for ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: ClassPattern (node) => node . get_range () , Self :: ComplexPattern (node) => node . get_range () , Self :: ConcatenatedString (node) => node . get_range () , Self :: DictPattern (node) => node . get_range () , Self :: DottedName (node) => node . get_range () , Self :: False (node) => node . get_range () , Self :: Float (node) => node . get_range () , Self :: Integer (node) => node . get_range () , Self :: ListPattern (node) => node . get_range () , Self :: None (node) => node . get_range () , Self :: SplatPattern (node) => node . get_range () , Self :: String (node) => node . get_range () , Self :: True (node) => node . get_range () , Self :: TuplePattern (node) => node . get_range () , Self :: UnionPattern (node) => node . get_range () } } } impl ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 174u16 | 175u16 | 231u16 | 170u16 | 163u16 | 97u16 | 94u16 | 93u16 | 181u16 | 98u16 | 173u16 | 232u16 | 96u16 | 180u16 | 167u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 174u16 => Ok (Self :: ClassPattern (ClassPattern :: try_from ((node , & mut * index)) ?)) , 175u16 => Ok (Self :: ComplexPattern (ComplexPattern :: try_from ((node , & mut * index)) ?)) , 231u16 => Ok (Self :: ConcatenatedString (ConcatenatedString :: try_from ((node , & mut * index)) ?)) , 170u16 => Ok (Self :: DictPattern (DictPattern :: try_from ((node , & mut * index)) ?)) , 163u16 => Ok (Self :: DottedName (DottedName :: try_from ((node , & mut * index)) ?)) , 97u16 => Ok (Self :: False (False :: try_from ((node , & mut * index)) ?)) , 94u16 => Ok (Self :: Float (Float :: try_from ((node , & mut * index)) ?)) , 93u16 => Ok (Self :: Integer (Integer :: try_from ((node , & mut * index)) ?)) , 181u16 => Ok (Self :: ListPattern (ListPattern :: try_from ((node , & mut * index)) ?)) , 98u16 => Ok (Self :: None (None :: try_from ((node , & mut * index)) ?)) , 173u16 => Ok (Self :: SplatPattern (SplatPattern :: try_from ((node , & mut * index)) ?)) , 232u16 => Ok (Self :: String (String :: try_from ((node , & mut * index)) ?)) , 96u16 => Ok (Self :: True (True :: try_from ((node , & mut * index)) ?)) , 180u16 => Ok (Self :: TuplePattern (TuplePattern :: try_from ((node , & mut * index)) ?)) , 167u16 => Ok (Self :: UnionPattern (UnionPattern :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum ConstrainedType_Expression_GenericType_MemberType_SplatType_UnionType { ConstrainedType (ConstrainedType) , GenericType (GenericType) , MemberType (MemberType) , SplatType (SplatType) , UnionType (UnionType) , Expression (Expression) } impl auto_lsp :: core :: ast :: AstNode for ConstrainedType_Expression_GenericType_MemberType_SplatType_UnionType { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: ConstrainedType (node) => node . get_range () , Self :: GenericType (node) => node . get_range () , Self :: MemberType (node) => node . get_range () , Self :: SplatType (node) => node . get_range () , Self :: UnionType (node) => node . get_range () , Self :: Expression (node) => node . get_range () } } } impl ConstrainedType_Expression_GenericType_MemberType_SplatType_UnionType { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 213u16 | 211u16 | 214u16 | 210u16 | 212u16 | 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ConstrainedType_Expression_GenericType_MemberType_SplatType_UnionType { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 213u16 => Ok (Self :: ConstrainedType (ConstrainedType :: try_from ((node , & mut * index)) ?)) , 211u16 => Ok (Self :: GenericType (GenericType :: try_from ((node , & mut * index)) ?)) , 214u16 => Ok (Self :: MemberType (MemberType :: try_from ((node , & mut * index)) ?)) , 210u16 => Ok (Self :: SplatType (SplatType :: try_from ((node , & mut * index)) ?)) , 212u16 => Ok (Self :: UnionType (UnionType :: try_from ((node , & mut * index)) ?)) , # [doc = r" Super types"] 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16 => Ok (Self :: Expression (Expression :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (ConstrainedType_Expression_GenericType_MemberType_SplatType_UnionType) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum EscapeInterpolation_EscapeSequence { EscapeInterpolation (EscapeInterpolation) , EscapeSequence (EscapeSequence) } impl auto_lsp :: core :: ast :: AstNode for EscapeInterpolation_EscapeSequence { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: EscapeInterpolation (node) => node . get_range () , Self :: EscapeSequence (node) => node . get_range () } } } impl EscapeInterpolation_EscapeSequence { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 106u16 | 89u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for EscapeInterpolation_EscapeSequence { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 106u16 => Ok (Self :: EscapeInterpolation (EscapeInterpolation :: try_from ((node , & mut * index)) ?)) , 89u16 => Ok (Self :: EscapeSequence (EscapeSequence :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (EscapeInterpolation_EscapeSequence) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum DictionarySplat_Expression_KeywordArgument_ListSplat_ParenthesizedExpression { DictionarySplat (DictionarySplat) , KeywordArgument (KeywordArgument) , ListSplat (ListSplat) , ParenthesizedExpression (ParenthesizedExpression) , Expression (Expression) } impl auto_lsp :: core :: ast :: AstNode for DictionarySplat_Expression_KeywordArgument_ListSplat_ParenthesizedExpression { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: DictionarySplat (node) => node . get_range () , Self :: KeywordArgument (node) => node . get_range () , Self :: ListSplat (node) => node . get_range () , Self :: ParenthesizedExpression (node) => node . get_range () , Self :: Expression (node) => node . get_range () } } } impl DictionarySplat_Expression_KeywordArgument_ListSplat_ParenthesizedExpression { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 150u16 | 215u16 | 149u16 | 226u16 | 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for DictionarySplat_Expression_KeywordArgument_ListSplat_ParenthesizedExpression { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 150u16 => Ok (Self :: DictionarySplat (DictionarySplat :: try_from ((node , & mut * index)) ?)) , 215u16 => Ok (Self :: KeywordArgument (KeywordArgument :: try_from ((node , & mut * index)) ?)) , 149u16 => Ok (Self :: ListSplat (ListSplat :: try_from ((node , & mut * index)) ?)) , 226u16 => Ok (Self :: ParenthesizedExpression (ParenthesizedExpression :: try_from ((node , & mut * index)) ?)) , # [doc = r" Super types"] 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16 => Ok (Self :: Expression (Expression :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (DictionarySplat_Expression_KeywordArgument_ListSplat_ParenthesizedExpression) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Interpolation_StringContent_StringEnd_StringStart { Interpolation (Interpolation) , StringContent (StringContent) , StringEnd (StringEnd) , StringStart (StringStart) } impl auto_lsp :: core :: ast :: AstNode for Interpolation_StringContent_StringEnd_StringStart { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Interpolation (node) => node . get_range () , Self :: StringContent (node) => node . get_range () , Self :: StringEnd (node) => node . get_range () , Self :: StringStart (node) => node . get_range () } } } impl Interpolation_StringContent_StringEnd_StringStart { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 234u16 | 233u16 | 107u16 | 104u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Interpolation_StringContent_StringEnd_StringStart { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 234u16 => Ok (Self :: Interpolation (Interpolation :: try_from ((node , & mut * index)) ?)) , 233u16 => Ok (Self :: StringContent (StringContent :: try_from ((node , & mut * index)) ?)) , 107u16 => Ok (Self :: StringEnd (StringEnd :: try_from ((node , & mut * index)) ?)) , 104u16 => Ok (Self :: StringStart (StringStart :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Interpolation_StringContent_StringEnd_StringStart) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum DictionarySplatPattern_Identifier_ListSplatPattern { DictionarySplatPattern (DictionarySplatPattern) , Identifier (Identifier) , ListSplatPattern (ListSplatPattern) } impl auto_lsp :: core :: ast :: AstNode for DictionarySplatPattern_Identifier_ListSplatPattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: DictionarySplatPattern (node) => node . get_range () , Self :: Identifier (node) => node . get_range () , Self :: ListSplatPattern (node) => node . get_range () } } } impl DictionarySplatPattern_Identifier_ListSplatPattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 185u16 | 1u16 | 184u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for DictionarySplatPattern_Identifier_ListSplatPattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 185u16 => Ok (Self :: DictionarySplatPattern (DictionarySplatPattern :: try_from ((node , & mut * index)) ?)) , 1u16 => Ok (Self :: Identifier (Identifier :: try_from ((node , & mut * index)) ?)) , 184u16 => Ok (Self :: ListSplatPattern (ListSplatPattern :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (DictionarySplatPattern_Identifier_ListSplatPattern) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum CasePattern_Expression_Identifier { CasePattern (CasePattern) , Identifier (Identifier) , Expression (Expression) } impl auto_lsp :: core :: ast :: AstNode for CasePattern_Expression_Identifier { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: CasePattern (node) => node . get_range () , Self :: Identifier (node) => node . get_range () , Self :: Expression (node) => node . get_range () } } } impl CasePattern_Expression_Identifier { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 164u16 | 1u16 | 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for CasePattern_Expression_Identifier { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 164u16 => Ok (Self :: CasePattern (CasePattern :: try_from ((node , & mut * index)) ?)) , 1u16 => Ok (Self :: Identifier (Identifier :: try_from ((node , & mut * index)) ?)) , # [doc = r" Super types"] 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16 => Ok (Self :: Expression (Expression :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (CasePattern_Expression_Identifier) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum ListSplat_ParenthesizedExpression { ListSplat (ListSplat) , ParenthesizedExpression (ParenthesizedExpression) } impl auto_lsp :: core :: ast :: AstNode for ListSplat_ParenthesizedExpression { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: ListSplat (node) => node . get_range () , Self :: ParenthesizedExpression (node) => node . get_range () } } } impl ListSplat_ParenthesizedExpression { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 149u16 | 226u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ListSplat_ParenthesizedExpression { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 149u16 => Ok (Self :: ListSplat (ListSplat :: try_from ((node , & mut * index)) ?)) , 226u16 => Ok (Self :: ParenthesizedExpression (ParenthesizedExpression :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (ListSplat_ParenthesizedExpression) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum DictionarySplat_Pair { DictionarySplat (DictionarySplat) , Pair (Pair) } impl auto_lsp :: core :: ast :: AstNode for DictionarySplat_Pair { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: DictionarySplat (node) => node . get_range () , Self :: Pair (node) => node . get_range () } } } impl DictionarySplat_Pair { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 150u16 | 220u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for DictionarySplat_Pair { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 150u16 => Ok (Self :: DictionarySplat (DictionarySplat :: try_from ((node , & mut * index)) ?)) , 220u16 => Ok (Self :: Pair (Pair :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (DictionarySplat_Pair) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum ForInClause_IfClause { ForInClause (ForInClause) , IfClause (IfClause) } impl auto_lsp :: core :: ast :: AstNode for ForInClause_IfClause { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: ForInClause (node) => node . get_range () , Self :: IfClause (node) => node . get_range () } } } impl ForInClause_IfClause { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 228u16 | 229u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ForInClause_IfClause { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 228u16 => Ok (Self :: ForInClause (ForInClause :: try_from ((node , & mut * index)) ?)) , 229u16 => Ok (Self :: IfClause (IfClause :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (ForInClause_IfClause) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Block_Expression { Block (Block) , Expression (Expression) } impl auto_lsp :: core :: ast :: AstNode for Block_Expression { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Block (node) => node . get_range () , Self :: Expression (node) => node . get_range () } } } impl Block_Expression { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 161u16 | 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Block_Expression { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 161u16 => Ok (Self :: Block (Block :: try_from ((node , & mut * index)) ?)) , # [doc = r" Super types"] 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16 => Ok (Self :: Expression (Expression :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Block_Expression) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Identifier_String { Identifier (Identifier) , String (String) } impl auto_lsp :: core :: ast :: AstNode for Identifier_String { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Identifier (node) => node . get_range () , Self :: String (node) => node . get_range () } } } impl Identifier_String { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 1u16 | 232u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Identifier_String { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 1u16 => Ok (Self :: Identifier (Identifier :: try_from ((node , & mut * index)) ?)) , 232u16 => Ok (Self :: String (String :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Identifier_String) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Comma_Expression { Token_Comma (Token_Comma) , Expression (Expression) } impl auto_lsp :: core :: ast :: AstNode for Comma_Expression { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Token_Comma (node) => node . get_range () , Self :: Expression (node) => node . get_range () } } } impl Comma_Expression { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 9u16 | 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Comma_Expression { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 9u16 => Ok (Self :: Token_Comma (Token_Comma :: try_from ((node , & mut * index)) ?)) , # [doc = r" Super types"] 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16 => Ok (Self :: Expression (Expression :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Comma_Expression) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum ElifClause_ElseClause { ElifClause (ElifClause) , ElseClause (ElseClause) } impl auto_lsp :: core :: ast :: AstNode for ElifClause_ElseClause { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: ElifClause (node) => node . get_range () , Self :: ElseClause (node) => node . get_range () } } } impl ElifClause_ElseClause { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 132u16 | 133u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ElifClause_ElseClause { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 132u16 => Ok (Self :: ElifClause (ElifClause :: try_from ((node , & mut * index)) ?)) , 133u16 => Ok (Self :: ElseClause (ElseClause :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (ElifClause_ElseClause) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Assignment_AugmentedAssignment_Expression_Yield { Assignment (Assignment) , AugmentedAssignment (AugmentedAssignment) , Yield (Yield) , Expression (Expression) } impl auto_lsp :: core :: ast :: AstNode for Assignment_AugmentedAssignment_Expression_Yield { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Assignment (node) => node . get_range () , Self :: AugmentedAssignment (node) => node . get_range () , Self :: Yield (node) => node . get_range () , Self :: Expression (node) => node . get_range () } } } impl Assignment_AugmentedAssignment_Expression_Yield { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 199u16 | 200u16 | 203u16 | 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Assignment_AugmentedAssignment_Expression_Yield { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 199u16 => Ok (Self :: Assignment (Assignment :: try_from ((node , & mut * index)) ?)) , 200u16 => Ok (Self :: AugmentedAssignment (AugmentedAssignment :: try_from ((node , & mut * index)) ?)) , 203u16 => Ok (Self :: Yield (Yield :: try_from ((node , & mut * index)) ?)) , # [doc = r" Super types"] 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16 => Ok (Self :: Expression (Expression :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Assignment_AugmentedAssignment_Expression_Yield) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Identifier_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern { ClassPattern (ClassPattern) , ComplexPattern (ComplexPattern) , ConcatenatedString (ConcatenatedString) , DictPattern (DictPattern) , DottedName (DottedName) , False (False) , Float (Float) , Identifier (Identifier) , Integer (Integer) , ListPattern (ListPattern) , None (None) , SplatPattern (SplatPattern) , String (String) , True (True) , TuplePattern (TuplePattern) , UnionPattern (UnionPattern) } impl auto_lsp :: core :: ast :: AstNode for ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Identifier_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: ClassPattern (node) => node . get_range () , Self :: ComplexPattern (node) => node . get_range () , Self :: ConcatenatedString (node) => node . get_range () , Self :: DictPattern (node) => node . get_range () , Self :: DottedName (node) => node . get_range () , Self :: False (node) => node . get_range () , Self :: Float (node) => node . get_range () , Self :: Identifier (node) => node . get_range () , Self :: Integer (node) => node . get_range () , Self :: ListPattern (node) => node . get_range () , Self :: None (node) => node . get_range () , Self :: SplatPattern (node) => node . get_range () , Self :: String (node) => node . get_range () , Self :: True (node) => node . get_range () , Self :: TuplePattern (node) => node . get_range () , Self :: UnionPattern (node) => node . get_range () } } } impl ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Identifier_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 174u16 | 175u16 | 231u16 | 170u16 | 163u16 | 97u16 | 94u16 | 1u16 | 93u16 | 181u16 | 98u16 | 173u16 | 232u16 | 96u16 | 180u16 | 167u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Identifier_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 174u16 => Ok (Self :: ClassPattern (ClassPattern :: try_from ((node , & mut * index)) ?)) , 175u16 => Ok (Self :: ComplexPattern (ComplexPattern :: try_from ((node , & mut * index)) ?)) , 231u16 => Ok (Self :: ConcatenatedString (ConcatenatedString :: try_from ((node , & mut * index)) ?)) , 170u16 => Ok (Self :: DictPattern (DictPattern :: try_from ((node , & mut * index)) ?)) , 163u16 => Ok (Self :: DottedName (DottedName :: try_from ((node , & mut * index)) ?)) , 97u16 => Ok (Self :: False (False :: try_from ((node , & mut * index)) ?)) , 94u16 => Ok (Self :: Float (Float :: try_from ((node , & mut * index)) ?)) , 1u16 => Ok (Self :: Identifier (Identifier :: try_from ((node , & mut * index)) ?)) , 93u16 => Ok (Self :: Integer (Integer :: try_from ((node , & mut * index)) ?)) , 181u16 => Ok (Self :: ListPattern (ListPattern :: try_from ((node , & mut * index)) ?)) , 98u16 => Ok (Self :: None (None :: try_from ((node , & mut * index)) ?)) , 173u16 => Ok (Self :: SplatPattern (SplatPattern :: try_from ((node , & mut * index)) ?)) , 232u16 => Ok (Self :: String (String :: try_from ((node , & mut * index)) ?)) , 96u16 => Ok (Self :: True (True :: try_from ((node , & mut * index)) ?)) , 180u16 => Ok (Self :: TuplePattern (TuplePattern :: try_from ((node , & mut * index)) ?)) , 167u16 => Ok (Self :: UnionPattern (UnionPattern :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Identifier_Integer_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Identifier_TypeParameter { Identifier (Identifier) , TypeParameter (TypeParameter) } impl auto_lsp :: core :: ast :: AstNode for Identifier_TypeParameter { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Identifier (node) => node . get_range () , Self :: TypeParameter (node) => node . get_range () } } } impl Identifier_TypeParameter { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 1u16 | 156u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Identifier_TypeParameter { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 1u16 => Ok (Self :: Identifier (Identifier :: try_from ((node , & mut * index)) ?)) , 156u16 => Ok (Self :: TypeParameter (TypeParameter :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Identifier_TypeParameter) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum CompoundStatement_SimpleStatement { CompoundStatement (CompoundStatement) , SimpleStatement (SimpleStatement) } impl auto_lsp :: core :: ast :: AstNode for CompoundStatement_SimpleStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: CompoundStatement (node) => node . get_range () , Self :: SimpleStatement (node) => node . get_range () } } } impl CompoundStatement_SimpleStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 155u16 | 159u16 | 137u16 | 146u16 | 131u16 | 134u16 | 139u16 | 138u16 | 143u16 | 121u16 | 129u16 | 130u16 | 126u16 | 153u16 | 122u16 | 114u16 | 151u16 | 115u16 | 111u16 | 152u16 | 128u16 | 119u16 | 127u16 | 125u16 | 154u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for CompoundStatement_SimpleStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { # [doc = r" Super types"] 155u16 | 159u16 | 137u16 | 146u16 | 131u16 | 134u16 | 139u16 | 138u16 | 143u16 => Ok (Self :: CompoundStatement (CompoundStatement :: try_from ((node , & mut * index)) ?)) , 121u16 | 129u16 | 130u16 | 126u16 | 153u16 | 122u16 | 114u16 | 151u16 | 115u16 | 111u16 | 152u16 | 128u16 | 119u16 | 127u16 | 125u16 | 154u16 => Ok (Self :: SimpleStatement (SimpleStatement :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (CompoundStatement_SimpleStatement) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum ArgumentList_GeneratorExpression { ArgumentList (ArgumentList) , GeneratorExpression (GeneratorExpression) } impl auto_lsp :: core :: ast :: AstNode for ArgumentList_GeneratorExpression { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: ArgumentList (node) => node . get_range () , Self :: GeneratorExpression (node) => node . get_range () } } } impl ArgumentList_GeneratorExpression { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 158u16 | 224u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ArgumentList_GeneratorExpression { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 158u16 => Ok (Self :: ArgumentList (ArgumentList :: try_from ((node , & mut * index)) ?)) , 224u16 => Ok (Self :: GeneratorExpression (GeneratorExpression :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (ArgumentList_GeneratorExpression) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum AsPattern_ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_KeywordPattern_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern { AsPattern (AsPattern) , ClassPattern (ClassPattern) , ComplexPattern (ComplexPattern) , ConcatenatedString (ConcatenatedString) , DictPattern (DictPattern) , DottedName (DottedName) , False (False) , Float (Float) , Integer (Integer) , KeywordPattern (KeywordPattern) , ListPattern (ListPattern) , None (None) , SplatPattern (SplatPattern) , String (String) , True (True) , TuplePattern (TuplePattern) , UnionPattern (UnionPattern) } impl auto_lsp :: core :: ast :: AstNode for AsPattern_ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_KeywordPattern_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: AsPattern (node) => node . get_range () , Self :: ClassPattern (node) => node . get_range () , Self :: ComplexPattern (node) => node . get_range () , Self :: ConcatenatedString (node) => node . get_range () , Self :: DictPattern (node) => node . get_range () , Self :: DottedName (node) => node . get_range () , Self :: False (node) => node . get_range () , Self :: Float (node) => node . get_range () , Self :: Integer (node) => node . get_range () , Self :: KeywordPattern (node) => node . get_range () , Self :: ListPattern (node) => node . get_range () , Self :: None (node) => node . get_range () , Self :: SplatPattern (node) => node . get_range () , Self :: String (node) => node . get_range () , Self :: True (node) => node . get_range () , Self :: TuplePattern (node) => node . get_range () , Self :: UnionPattern (node) => node . get_range () } } } impl AsPattern_ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_KeywordPattern_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 186u16 | 174u16 | 175u16 | 231u16 | 170u16 | 163u16 | 97u16 | 94u16 | 93u16 | 172u16 | 181u16 | 98u16 | 173u16 | 232u16 | 96u16 | 180u16 | 167u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for AsPattern_ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_KeywordPattern_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 186u16 => Ok (Self :: AsPattern (AsPattern :: try_from ((node , & mut * index)) ?)) , 174u16 => Ok (Self :: ClassPattern (ClassPattern :: try_from ((node , & mut * index)) ?)) , 175u16 => Ok (Self :: ComplexPattern (ComplexPattern :: try_from ((node , & mut * index)) ?)) , 231u16 => Ok (Self :: ConcatenatedString (ConcatenatedString :: try_from ((node , & mut * index)) ?)) , 170u16 => Ok (Self :: DictPattern (DictPattern :: try_from ((node , & mut * index)) ?)) , 163u16 => Ok (Self :: DottedName (DottedName :: try_from ((node , & mut * index)) ?)) , 97u16 => Ok (Self :: False (False :: try_from ((node , & mut * index)) ?)) , 94u16 => Ok (Self :: Float (Float :: try_from ((node , & mut * index)) ?)) , 93u16 => Ok (Self :: Integer (Integer :: try_from ((node , & mut * index)) ?)) , 172u16 => Ok (Self :: KeywordPattern (KeywordPattern :: try_from ((node , & mut * index)) ?)) , 181u16 => Ok (Self :: ListPattern (ListPattern :: try_from ((node , & mut * index)) ?)) , 98u16 => Ok (Self :: None (None :: try_from ((node , & mut * index)) ?)) , 173u16 => Ok (Self :: SplatPattern (SplatPattern :: try_from ((node , & mut * index)) ?)) , 232u16 => Ok (Self :: String (String :: try_from ((node , & mut * index)) ?)) , 96u16 => Ok (Self :: True (True :: try_from ((node , & mut * index)) ?)) , 180u16 => Ok (Self :: TuplePattern (TuplePattern :: try_from ((node , & mut * index)) ?)) , 167u16 => Ok (Self :: UnionPattern (UnionPattern :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (AsPattern_ClassPattern_ComplexPattern_ConcatenatedString_DictPattern_DottedName_False_Float_Integer_KeywordPattern_ListPattern_None_SplatPattern_String_True_TuplePattern_UnionPattern) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Expression_ExpressionList { ExpressionList (ExpressionList) , Expression (Expression) } impl auto_lsp :: core :: ast :: AstNode for Expression_ExpressionList { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: ExpressionList (node) => node . get_range () , Self :: Expression (node) => node . get_range () } } } impl Expression_ExpressionList { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 162u16 | 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Expression_ExpressionList { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 162u16 => Ok (Self :: ExpressionList (ExpressionList :: try_from ((node , & mut * index)) ?)) , # [doc = r" Super types"] 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16 => Ok (Self :: Expression (Expression :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Expression_ExpressionList) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum AliasedImport_DottedName { AliasedImport (AliasedImport) , DottedName (DottedName) } impl auto_lsp :: core :: ast :: AstNode for AliasedImport_DottedName { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: AliasedImport (node) => node . get_range () , Self :: DottedName (node) => node . get_range () } } } impl AliasedImport_DottedName { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 117u16 | 163u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for AliasedImport_DottedName { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 117u16 => Ok (Self :: AliasedImport (AliasedImport :: try_from ((node , & mut * index)) ?)) , 163u16 => Ok (Self :: DottedName (DottedName :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (AliasedImport_DottedName) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum ElseClause_ExceptClause_ExceptGroupClause_FinallyClause { ElseClause (ElseClause) , ExceptClause (ExceptClause) , ExceptGroupClause (ExceptGroupClause) , FinallyClause (FinallyClause) } impl auto_lsp :: core :: ast :: AstNode for ElseClause_ExceptClause_ExceptGroupClause_FinallyClause { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: ElseClause (node) => node . get_range () , Self :: ExceptClause (node) => node . get_range () , Self :: ExceptGroupClause (node) => node . get_range () , Self :: FinallyClause (node) => node . get_range () } } } impl ElseClause_ExceptClause_ExceptGroupClause_FinallyClause { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 133u16 | 140u16 | 141u16 | 142u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for ElseClause_ExceptClause_ExceptGroupClause_FinallyClause { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 133u16 => Ok (Self :: ElseClause (ElseClause :: try_from ((node , & mut * index)) ?)) , 140u16 => Ok (Self :: ExceptClause (ExceptClause :: try_from ((node , & mut * index)) ?)) , 141u16 => Ok (Self :: ExceptGroupClause (ExceptGroupClause :: try_from ((node , & mut * index)) ?)) , 142u16 => Ok (Self :: FinallyClause (FinallyClause :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (ElseClause_ExceptClause_ExceptGroupClause_FinallyClause) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Pattern_PatternList { PatternList (PatternList) , Pattern (Pattern) } impl auto_lsp :: core :: ast :: AstNode for Pattern_PatternList { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: PatternList (node) => node . get_range () , Self :: Pattern (node) => node . get_range () } } } impl Pattern_PatternList { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 201u16 | 204u16 | 1u16 | 181u16 | 184u16 | 205u16 | 180u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Pattern_PatternList { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 201u16 => Ok (Self :: PatternList (PatternList :: try_from ((node , & mut * index)) ?)) , # [doc = r" Super types"] 204u16 | 1u16 | 181u16 | 184u16 | 205u16 | 180u16 => Ok (Self :: Pattern (Pattern :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Pattern_PatternList) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Expression_ListSplat_ParenthesizedListSplat_Yield { ListSplat (ListSplat) , ParenthesizedListSplat (ParenthesizedListSplat) , Yield (Yield) , Expression (Expression) } impl auto_lsp :: core :: ast :: AstNode for Expression_ListSplat_ParenthesizedListSplat_Yield { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: ListSplat (node) => node . get_range () , Self :: ParenthesizedListSplat (node) => node . get_range () , Self :: Yield (node) => node . get_range () , Self :: Expression (node) => node . get_range () } } } impl Expression_ListSplat_ParenthesizedListSplat_Yield { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 149u16 | 157u16 | 203u16 | 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Expression_ListSplat_ParenthesizedListSplat_Yield { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 149u16 => Ok (Self :: ListSplat (ListSplat :: try_from ((node , & mut * index)) ?)) , 157u16 => Ok (Self :: ParenthesizedListSplat (ParenthesizedListSplat :: try_from ((node , & mut * index)) ?)) , 203u16 => Ok (Self :: Yield (Yield :: try_from ((node , & mut * index)) ?)) , # [doc = r" Super types"] 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16 => Ok (Self :: Expression (Expression :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Expression_ListSplat_ParenthesizedListSplat_Yield) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum DottedName_ImportPrefix { DottedName (DottedName) , ImportPrefix (ImportPrefix) } impl auto_lsp :: core :: ast :: AstNode for DottedName_ImportPrefix { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: DottedName (node) => node . get_range () , Self :: ImportPrefix (node) => node . get_range () } } } impl DottedName_ImportPrefix { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 163u16 | 112u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for DottedName_ImportPrefix { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 163u16 => Ok (Self :: DottedName (DottedName :: try_from ((node , & mut * index)) ?)) , 112u16 => Ok (Self :: ImportPrefix (ImportPrefix :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (DottedName_ImportPrefix) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Attribute_Expression_Identifier_Subscript { Attribute (Attribute) , Identifier (Identifier) , Subscript (Subscript) , Expression (Expression) } impl auto_lsp :: core :: ast :: AstNode for Attribute_Expression_Identifier_Subscript { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Attribute (node) => node . get_range () , Self :: Identifier (node) => node . get_range () , Self :: Subscript (node) => node . get_range () , Self :: Expression (node) => node . get_range () } } } impl Attribute_Expression_Identifier_Subscript { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 204u16 | 1u16 | 205u16 | 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Attribute_Expression_Identifier_Subscript { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 204u16 => Ok (Self :: Attribute (Attribute :: try_from ((node , & mut * index)) ?)) , 1u16 => Ok (Self :: Identifier (Identifier :: try_from ((node , & mut * index)) ?)) , 205u16 => Ok (Self :: Subscript (Subscript :: try_from ((node , & mut * index)) ?)) , # [doc = r" Super types"] 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16 => Ok (Self :: Expression (Expression :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Attribute_Expression_Identifier_Subscript) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Expression_ListSplat_ParenthesizedExpression_Yield { ListSplat (ListSplat) , ParenthesizedExpression (ParenthesizedExpression) , Yield (Yield) , Expression (Expression) } impl auto_lsp :: core :: ast :: AstNode for Expression_ListSplat_ParenthesizedExpression_Yield { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: ListSplat (node) => node . get_range () , Self :: ParenthesizedExpression (node) => node . get_range () , Self :: Yield (node) => node . get_range () , Self :: Expression (node) => node . get_range () } } } impl Expression_ListSplat_ParenthesizedExpression_Yield { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 149u16 | 226u16 | 203u16 | 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Expression_ListSplat_ParenthesizedExpression_Yield { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 149u16 => Ok (Self :: ListSplat (ListSplat :: try_from ((node , & mut * index)) ?)) , 226u16 => Ok (Self :: ParenthesizedExpression (ParenthesizedExpression :: try_from ((node , & mut * index)) ?)) , 203u16 => Ok (Self :: Yield (Yield :: try_from ((node , & mut * index)) ?)) , # [doc = r" Super types"] 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16 => Ok (Self :: Expression (Expression :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Expression_ListSplat_ParenthesizedExpression_Yield) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Expression_Slice { Slice (Slice) , Expression (Expression) } impl auto_lsp :: core :: ast :: AstNode for Expression_Slice { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Slice (node) => node . get_range () , Self :: Expression (node) => node . get_range () } } } impl Expression_Slice { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 206u16 | 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Expression_Slice { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 206u16 => Ok (Self :: Slice (Slice :: try_from ((node , & mut * index)) ?)) , # [doc = r" Super types"] 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16 => Ok (Self :: Expression (Expression :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Expression_Slice) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum CasePattern_DottedName { CasePattern (CasePattern) , DottedName (DottedName) } impl auto_lsp :: core :: ast :: AstNode for CasePattern_DottedName { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: CasePattern (node) => node . get_range () , Self :: DottedName (node) => node . get_range () } } } impl CasePattern_DottedName { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 164u16 | 163u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for CasePattern_DottedName { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 164u16 => Ok (Self :: CasePattern (CasePattern :: try_from ((node , & mut * index)) ?)) , 163u16 => Ok (Self :: DottedName (DottedName :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (CasePattern_DottedName) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Assignment_AugmentedAssignment_Expression_ExpressionList_PatternList_Yield { Assignment (Assignment) , AugmentedAssignment (AugmentedAssignment) , ExpressionList (ExpressionList) , PatternList (PatternList) , Yield (Yield) , Expression (Expression) } impl auto_lsp :: core :: ast :: AstNode for Assignment_AugmentedAssignment_Expression_ExpressionList_PatternList_Yield { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Assignment (node) => node . get_range () , Self :: AugmentedAssignment (node) => node . get_range () , Self :: ExpressionList (node) => node . get_range () , Self :: PatternList (node) => node . get_range () , Self :: Yield (node) => node . get_range () , Self :: Expression (node) => node . get_range () } } } impl Assignment_AugmentedAssignment_Expression_ExpressionList_PatternList_Yield { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 199u16 | 200u16 | 162u16 | 201u16 | 203u16 | 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Assignment_AugmentedAssignment_Expression_ExpressionList_PatternList_Yield { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 199u16 => Ok (Self :: Assignment (Assignment :: try_from ((node , & mut * index)) ?)) , 200u16 => Ok (Self :: AugmentedAssignment (AugmentedAssignment :: try_from ((node , & mut * index)) ?)) , 162u16 => Ok (Self :: ExpressionList (ExpressionList :: try_from ((node , & mut * index)) ?)) , 201u16 => Ok (Self :: PatternList (PatternList :: try_from ((node , & mut * index)) ?)) , 203u16 => Ok (Self :: Yield (Yield :: try_from ((node , & mut * index)) ?)) , # [doc = r" Super types"] 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16 => Ok (Self :: Expression (Expression :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Assignment_AugmentedAssignment_Expression_ExpressionList_PatternList_Yield) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Expression_ExpressionList_PatternList_Yield { ExpressionList (ExpressionList) , PatternList (PatternList) , Yield (Yield) , Expression (Expression) } impl auto_lsp :: core :: ast :: AstNode for Expression_ExpressionList_PatternList_Yield { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: ExpressionList (node) => node . get_range () , Self :: PatternList (node) => node . get_range () , Self :: Yield (node) => node . get_range () , Self :: Expression (node) => node . get_range () } } } impl Expression_ExpressionList_PatternList_Yield { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 162u16 | 201u16 | 203u16 | 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Expression_ExpressionList_PatternList_Yield { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 162u16 => Ok (Self :: ExpressionList (ExpressionList :: try_from ((node , & mut * index)) ?)) , 201u16 => Ok (Self :: PatternList (PatternList :: try_from ((node , & mut * index)) ?)) , 203u16 => Ok (Self :: Yield (Yield :: try_from ((node , & mut * index)) ?)) , # [doc = r" Super types"] 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16 => Ok (Self :: Expression (Expression :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Expression_ExpressionList_PatternList_Yield) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Identifier_TuplePattern { Identifier (Identifier) , TuplePattern (TuplePattern) } impl auto_lsp :: core :: ast :: AstNode for Identifier_TuplePattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Identifier (node) => node . get_range () , Self :: TuplePattern (node) => node . get_range () } } } impl Identifier_TuplePattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 1u16 | 180u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Identifier_TuplePattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 1u16 => Ok (Self :: Identifier (Identifier :: try_from ((node , & mut * index)) ?)) , 180u16 => Ok (Self :: TuplePattern (TuplePattern :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Identifier_TuplePattern) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum DottedName_RelativeImport { DottedName (DottedName) , RelativeImport (RelativeImport) } impl auto_lsp :: core :: ast :: AstNode for DottedName_RelativeImport { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: DottedName (node) => node . get_range () , Self :: RelativeImport (node) => node . get_range () } } } impl DottedName_RelativeImport { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 163u16 | 113u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for DottedName_RelativeImport { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 163u16 => Ok (Self :: DottedName (DottedName :: try_from ((node , & mut * index)) ?)) , 113u16 => Ok (Self :: RelativeImport (RelativeImport :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (DottedName_RelativeImport) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum CasePattern_Pattern { CasePattern (CasePattern) , Pattern (Pattern) } impl auto_lsp :: core :: ast :: AstNode for CasePattern_Pattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: CasePattern (node) => node . get_range () , Self :: Pattern (node) => node . get_range () } } } impl CasePattern_Pattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 164u16 | 204u16 | 1u16 | 181u16 | 184u16 | 205u16 | 180u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for CasePattern_Pattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 164u16 => Ok (Self :: CasePattern (CasePattern :: try_from ((node , & mut * index)) ?)) , # [doc = r" Super types"] 204u16 | 1u16 | 181u16 | 184u16 | 205u16 | 180u16 => Ok (Self :: Pattern (Pattern :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (CasePattern_Pattern) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Float_Integer { Float (Float) , Integer (Integer) } impl auto_lsp :: core :: ast :: AstNode for Float_Integer { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Float (node) => node . get_range () , Self :: Integer (node) => node . get_range () } } } impl Float_Integer { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 94u16 | 93u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Float_Integer { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 94u16 => Ok (Self :: Float (Float :: try_from ((node , & mut * index)) ?)) , 93u16 => Ok (Self :: Integer (Integer :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Float_Integer) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Identifier_Type { Identifier (Identifier) , Type (Type) } impl auto_lsp :: core :: ast :: AstNode for Identifier_Type { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Identifier (node) => node . get_range () , Self :: Type (node) => node . get_range () } } } impl Identifier_Type { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 1u16 | 209u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Identifier_Type { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 1u16 => Ok (Self :: Identifier (Identifier :: try_from ((node , & mut * index)) ?)) , 209u16 => Ok (Self :: Type (Type :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Identifier_Type) , }) } } } # [derive (Debug , Clone , PartialEq)] pub struct AsPatternTarget { _range : auto_lsp :: tree_sitter :: Range } impl auto_lsp :: core :: ast :: AstNode for AsPatternTarget { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { & self . _range } } impl AsPatternTarget { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind () , "as_pattern_target") } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for AsPatternTarget { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { Ok (Self { _range : node . range () }) } } # [derive (Debug , Clone , PartialEq)] pub enum SimpleStatement { AssertStatement (AssertStatement) , BreakStatement (BreakStatement) , ContinueStatement (ContinueStatement) , DeleteStatement (DeleteStatement) , ExecStatement (ExecStatement) , ExpressionStatement (ExpressionStatement) , FutureImportStatement (FutureImportStatement) , GlobalStatement (GlobalStatement) , ImportFromStatement (ImportFromStatement) , ImportStatement (ImportStatement) , NonlocalStatement (NonlocalStatement) , PassStatement (PassStatement) , PrintStatement (PrintStatement) , RaiseStatement (RaiseStatement) , ReturnStatement (ReturnStatement) , TypeAliasStatement (TypeAliasStatement) } impl auto_lsp :: core :: ast :: AstNode for SimpleStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: AssertStatement (node) => node . get_range () , Self :: BreakStatement (node) => node . get_range () , Self :: ContinueStatement (node) => node . get_range () , Self :: DeleteStatement (node) => node . get_range () , Self :: ExecStatement (node) => node . get_range () , Self :: ExpressionStatement (node) => node . get_range () , Self :: FutureImportStatement (node) => node . get_range () , Self :: GlobalStatement (node) => node . get_range () , Self :: ImportFromStatement (node) => node . get_range () , Self :: ImportStatement (node) => node . get_range () , Self :: NonlocalStatement (node) => node . get_range () , Self :: PassStatement (node) => node . get_range () , Self :: PrintStatement (node) => node . get_range () , Self :: RaiseStatement (node) => node . get_range () , Self :: ReturnStatement (node) => node . get_range () , Self :: TypeAliasStatement (node) => node . get_range () } } } impl SimpleStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 121u16 | 129u16 | 130u16 | 126u16 | 153u16 | 122u16 | 114u16 | 151u16 | 115u16 | 111u16 | 152u16 | 128u16 | 119u16 | 127u16 | 125u16 | 154u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for SimpleStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 121u16 => Ok (Self :: AssertStatement (AssertStatement :: try_from ((node , & mut * index)) ?)) , 129u16 => Ok (Self :: BreakStatement (BreakStatement :: try_from ((node , & mut * index)) ?)) , 130u16 => Ok (Self :: ContinueStatement (ContinueStatement :: try_from ((node , & mut * index)) ?)) , 126u16 => Ok (Self :: DeleteStatement (DeleteStatement :: try_from ((node , & mut * index)) ?)) , 153u16 => Ok (Self :: ExecStatement (ExecStatement :: try_from ((node , & mut * index)) ?)) , 122u16 => Ok (Self :: ExpressionStatement (ExpressionStatement :: try_from ((node , & mut * index)) ?)) , 114u16 => Ok (Self :: FutureImportStatement (FutureImportStatement :: try_from ((node , & mut * index)) ?)) , 151u16 => Ok (Self :: GlobalStatement (GlobalStatement :: try_from ((node , & mut * index)) ?)) , 115u16 => Ok (Self :: ImportFromStatement (ImportFromStatement :: try_from ((node , & mut * index)) ?)) , 111u16 => Ok (Self :: ImportStatement (ImportStatement :: try_from ((node , & mut * index)) ?)) , 152u16 => Ok (Self :: NonlocalStatement (NonlocalStatement :: try_from ((node , & mut * index)) ?)) , 128u16 => Ok (Self :: PassStatement (PassStatement :: try_from ((node , & mut * index)) ?)) , 119u16 => Ok (Self :: PrintStatement (PrintStatement :: try_from ((node , & mut * index)) ?)) , 127u16 => Ok (Self :: RaiseStatement (RaiseStatement :: try_from ((node , & mut * index)) ?)) , 125u16 => Ok (Self :: ReturnStatement (ReturnStatement :: try_from ((node , & mut * index)) ?)) , 154u16 => Ok (Self :: TypeAliasStatement (TypeAliasStatement :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (SimpleStatement) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum CompoundStatement { ClassDefinition (ClassDefinition) , DecoratedDefinition (DecoratedDefinition) , ForStatement (ForStatement) , FunctionDefinition (FunctionDefinition) , IfStatement (IfStatement) , MatchStatement (MatchStatement) , TryStatement (TryStatement) , WhileStatement (WhileStatement) , WithStatement (WithStatement) } impl auto_lsp :: core :: ast :: AstNode for CompoundStatement { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: ClassDefinition (node) => node . get_range () , Self :: DecoratedDefinition (node) => node . get_range () , Self :: ForStatement (node) => node . get_range () , Self :: FunctionDefinition (node) => node . get_range () , Self :: IfStatement (node) => node . get_range () , Self :: MatchStatement (node) => node . get_range () , Self :: TryStatement (node) => node . get_range () , Self :: WhileStatement (node) => node . get_range () , Self :: WithStatement (node) => node . get_range () } } } impl CompoundStatement { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 155u16 | 159u16 | 137u16 | 146u16 | 131u16 | 134u16 | 139u16 | 138u16 | 143u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for CompoundStatement { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 155u16 => Ok (Self :: ClassDefinition (ClassDefinition :: try_from ((node , & mut * index)) ?)) , 159u16 => Ok (Self :: DecoratedDefinition (DecoratedDefinition :: try_from ((node , & mut * index)) ?)) , 137u16 => Ok (Self :: ForStatement (ForStatement :: try_from ((node , & mut * index)) ?)) , 146u16 => Ok (Self :: FunctionDefinition (FunctionDefinition :: try_from ((node , & mut * index)) ?)) , 131u16 => Ok (Self :: IfStatement (IfStatement :: try_from ((node , & mut * index)) ?)) , 134u16 => Ok (Self :: MatchStatement (MatchStatement :: try_from ((node , & mut * index)) ?)) , 139u16 => Ok (Self :: TryStatement (TryStatement :: try_from ((node , & mut * index)) ?)) , 138u16 => Ok (Self :: WhileStatement (WhileStatement :: try_from ((node , & mut * index)) ?)) , 143u16 => Ok (Self :: WithStatement (WithStatement :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (CompoundStatement) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Parameter { DefaultParameter (DefaultParameter) , DictionarySplatPattern (DictionarySplatPattern) , Identifier (Identifier) , KeywordSeparator (KeywordSeparator) , ListSplatPattern (ListSplatPattern) , PositionalSeparator (PositionalSeparator) , TuplePattern (TuplePattern) , TypedDefaultParameter (TypedDefaultParameter) , TypedParameter (TypedParameter) } impl auto_lsp :: core :: ast :: AstNode for Parameter { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: DefaultParameter (node) => node . get_range () , Self :: DictionarySplatPattern (node) => node . get_range () , Self :: Identifier (node) => node . get_range () , Self :: KeywordSeparator (node) => node . get_range () , Self :: ListSplatPattern (node) => node . get_range () , Self :: PositionalSeparator (node) => node . get_range () , Self :: TuplePattern (node) => node . get_range () , Self :: TypedDefaultParameter (node) => node . get_range () , Self :: TypedParameter (node) => node . get_range () } } } impl Parameter { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 182u16 | 185u16 | 1u16 | 240u16 | 184u16 | 239u16 | 180u16 | 183u16 | 208u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Parameter { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 182u16 => Ok (Self :: DefaultParameter (DefaultParameter :: try_from ((node , & mut * index)) ?)) , 185u16 => Ok (Self :: DictionarySplatPattern (DictionarySplatPattern :: try_from ((node , & mut * index)) ?)) , 1u16 => Ok (Self :: Identifier (Identifier :: try_from ((node , & mut * index)) ?)) , 240u16 => Ok (Self :: KeywordSeparator (KeywordSeparator :: try_from ((node , & mut * index)) ?)) , 184u16 => Ok (Self :: ListSplatPattern (ListSplatPattern :: try_from ((node , & mut * index)) ?)) , 239u16 => Ok (Self :: PositionalSeparator (PositionalSeparator :: try_from ((node , & mut * index)) ?)) , 180u16 => Ok (Self :: TuplePattern (TuplePattern :: try_from ((node , & mut * index)) ?)) , 183u16 => Ok (Self :: TypedDefaultParameter (TypedDefaultParameter :: try_from ((node , & mut * index)) ?)) , 208u16 => Ok (Self :: TypedParameter (TypedParameter :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Parameter) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Pattern { Attribute (Attribute) , Identifier (Identifier) , ListPattern (ListPattern) , ListSplatPattern (ListSplatPattern) , Subscript (Subscript) , TuplePattern (TuplePattern) } impl auto_lsp :: core :: ast :: AstNode for Pattern { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Attribute (node) => node . get_range () , Self :: Identifier (node) => node . get_range () , Self :: ListPattern (node) => node . get_range () , Self :: ListSplatPattern (node) => node . get_range () , Self :: Subscript (node) => node . get_range () , Self :: TuplePattern (node) => node . get_range () } } } impl Pattern { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 204u16 | 1u16 | 181u16 | 184u16 | 205u16 | 180u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Pattern { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 204u16 => Ok (Self :: Attribute (Attribute :: try_from ((node , & mut * index)) ?)) , 1u16 => Ok (Self :: Identifier (Identifier :: try_from ((node , & mut * index)) ?)) , 181u16 => Ok (Self :: ListPattern (ListPattern :: try_from ((node , & mut * index)) ?)) , 184u16 => Ok (Self :: ListSplatPattern (ListSplatPattern :: try_from ((node , & mut * index)) ?)) , 205u16 => Ok (Self :: Subscript (Subscript :: try_from ((node , & mut * index)) ?)) , 180u16 => Ok (Self :: TuplePattern (TuplePattern :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Pattern) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum PrimaryExpression { Attribute (Attribute) , Await (Await) , BinaryOperator (BinaryOperator) , Call (Call) , ConcatenatedString (ConcatenatedString) , Dictionary (Dictionary) , DictionaryComprehension (DictionaryComprehension) , Ellipsis (Ellipsis) , False (False) , Float (Float) , GeneratorExpression (GeneratorExpression) , Identifier (Identifier) , Integer (Integer) , List (List) , ListComprehension (ListComprehension) , ListSplat (ListSplat) , None (None) , ParenthesizedExpression (ParenthesizedExpression) , Set (Set) , SetComprehension (SetComprehension) , String (String) , Subscript (Subscript) , True (True) , Tuple (Tuple) , UnaryOperator (UnaryOperator) } impl auto_lsp :: core :: ast :: AstNode for PrimaryExpression { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: Attribute (node) => node . get_range () , Self :: Await (node) => node . get_range () , Self :: BinaryOperator (node) => node . get_range () , Self :: Call (node) => node . get_range () , Self :: ConcatenatedString (node) => node . get_range () , Self :: Dictionary (node) => node . get_range () , Self :: DictionaryComprehension (node) => node . get_range () , Self :: Ellipsis (node) => node . get_range () , Self :: False (node) => node . get_range () , Self :: Float (node) => node . get_range () , Self :: GeneratorExpression (node) => node . get_range () , Self :: Identifier (node) => node . get_range () , Self :: Integer (node) => node . get_range () , Self :: List (node) => node . get_range () , Self :: ListComprehension (node) => node . get_range () , Self :: ListSplat (node) => node . get_range () , Self :: None (node) => node . get_range () , Self :: ParenthesizedExpression (node) => node . get_range () , Self :: Set (node) => node . get_range () , Self :: SetComprehension (node) => node . get_range () , Self :: String (node) => node . get_range () , Self :: Subscript (node) => node . get_range () , Self :: True (node) => node . get_range () , Self :: Tuple (node) => node . get_range () , Self :: UnaryOperator (node) => node . get_range () } } } impl PrimaryExpression { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for PrimaryExpression { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 204u16 => Ok (Self :: Attribute (Attribute :: try_from ((node , & mut * index)) ?)) , 238u16 => Ok (Self :: Await (Await :: try_from ((node , & mut * index)) ?)) , 192u16 => Ok (Self :: BinaryOperator (BinaryOperator :: try_from ((node , & mut * index)) ?)) , 207u16 => Ok (Self :: Call (Call :: try_from ((node , & mut * index)) ?)) , 231u16 => Ok (Self :: ConcatenatedString (ConcatenatedString :: try_from ((node , & mut * index)) ?)) , 219u16 => Ok (Self :: Dictionary (Dictionary :: try_from ((node , & mut * index)) ?)) , 222u16 => Ok (Self :: DictionaryComprehension (DictionaryComprehension :: try_from ((node , & mut * index)) ?)) , 88u16 => Ok (Self :: Ellipsis (Ellipsis :: try_from ((node , & mut * index)) ?)) , 97u16 => Ok (Self :: False (False :: try_from ((node , & mut * index)) ?)) , 94u16 => Ok (Self :: Float (Float :: try_from ((node , & mut * index)) ?)) , 224u16 => Ok (Self :: GeneratorExpression (GeneratorExpression :: try_from ((node , & mut * index)) ?)) , 1u16 => Ok (Self :: Identifier (Identifier :: try_from ((node , & mut * index)) ?)) , 93u16 => Ok (Self :: Integer (Integer :: try_from ((node , & mut * index)) ?)) , 216u16 => Ok (Self :: List (List :: try_from ((node , & mut * index)) ?)) , 221u16 => Ok (Self :: ListComprehension (ListComprehension :: try_from ((node , & mut * index)) ?)) , 149u16 => Ok (Self :: ListSplat (ListSplat :: try_from ((node , & mut * index)) ?)) , 98u16 => Ok (Self :: None (None :: try_from ((node , & mut * index)) ?)) , 226u16 => Ok (Self :: ParenthesizedExpression (ParenthesizedExpression :: try_from ((node , & mut * index)) ?)) , 217u16 => Ok (Self :: Set (Set :: try_from ((node , & mut * index)) ?)) , 223u16 => Ok (Self :: SetComprehension (SetComprehension :: try_from ((node , & mut * index)) ?)) , 232u16 => Ok (Self :: String (String :: try_from ((node , & mut * index)) ?)) , 205u16 => Ok (Self :: Subscript (Subscript :: try_from ((node , & mut * index)) ?)) , 96u16 => Ok (Self :: True (True :: try_from ((node , & mut * index)) ?)) , 218u16 => Ok (Self :: Tuple (Tuple :: try_from ((node , & mut * index)) ?)) , 193u16 => Ok (Self :: UnaryOperator (UnaryOperator :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (PrimaryExpression) , }) } } } # [derive (Debug , Clone , PartialEq)] pub enum Expression { AsPattern (AsPattern) , BooleanOperator (BooleanOperator) , ComparisonOperator (ComparisonOperator) , ConditionalExpression (ConditionalExpression) , Lambda (Lambda) , NamedExpression (NamedExpression) , NotOperator (NotOperator) , PrimaryExpression (PrimaryExpression) } impl auto_lsp :: core :: ast :: AstNode for Expression { fn get_range (& self) -> & auto_lsp :: tree_sitter :: Range { match self { Self :: AsPattern (node) => node . get_range () , Self :: BooleanOperator (node) => node . get_range () , Self :: ComparisonOperator (node) => node . get_range () , Self :: ConditionalExpression (node) => node . get_range () , Self :: Lambda (node) => node . get_range () , Self :: NamedExpression (node) => node . get_range () , Self :: NotOperator (node) => node . get_range () , Self :: PrimaryExpression (node) => node . get_range () } } } impl Expression { pub fn contains (node : & auto_lsp :: tree_sitter :: Node) -> bool { matches ! (node . kind_id () , 186u16 | 191u16 | 196u16 | 230u16 | 197u16 | 123u16 | 190u16 | 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16) } } impl TryFrom < (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>) > for Expression { type Error = auto_lsp :: core :: errors :: AstError ; fn try_from ((node , index) : (& auto_lsp :: tree_sitter :: Node < '_ > , & mut Vec < std :: sync :: Arc < dyn auto_lsp :: core :: ast :: AstNode >>)) -> Result < Self , Self :: Error > { match node . kind_id () { 186u16 => Ok (Self :: AsPattern (AsPattern :: try_from ((node , & mut * index)) ?)) , 191u16 => Ok (Self :: BooleanOperator (BooleanOperator :: try_from ((node , & mut * index)) ?)) , 196u16 => Ok (Self :: ComparisonOperator (ComparisonOperator :: try_from ((node , & mut * index)) ?)) , 230u16 => Ok (Self :: ConditionalExpression (ConditionalExpression :: try_from ((node , & mut * index)) ?)) , 197u16 => Ok (Self :: Lambda (Lambda :: try_from ((node , & mut * index)) ?)) , 123u16 => Ok (Self :: NamedExpression (NamedExpression :: try_from ((node , & mut * index)) ?)) , 190u16 => Ok (Self :: NotOperator (NotOperator :: try_from ((node , & mut * index)) ?)) , # [doc = r" Super types"] 204u16 | 238u16 | 192u16 | 207u16 | 231u16 | 219u16 | 222u16 | 88u16 | 97u16 | 94u16 | 224u16 | 1u16 | 93u16 | 216u16 | 221u16 | 149u16 | 98u16 | 226u16 | 217u16 | 223u16 | 232u16 | 205u16 | 96u16 | 218u16 | 193u16 => Ok (Self :: PrimaryExpression (PrimaryExpression :: try_from ((node , & mut * index)) ?)) , _ => Err (auto_lsp :: core :: errors :: AstError :: UnexpectedSymbol { range : node . range () , symbol : node . kind () , parent_name : stringify ! (Expression) , }) } } }