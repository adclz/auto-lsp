# Configuring Semantic Tokens

To configure semantic tokens, you need to define the token types and modifiers that will be used in your language server.

```rust
# use auto_lsp::lsp_types::SemanticTokenType;
# use auto_lsp::define_semantic_token_types;
# use phf::phf_map;
define_semantic_token_types! {
    standard {
         "namespace" => NAMESPACE,
         "type" => TYPE,
         "function" => FUNCTION,
    }
}
```

By defining semantic token types in one place, you can easily reuse them in both your Abstract Syntax Tree (AST) and the LSP server options, ensuring consistency across your language server implementation.

```rust

use auto_lsp::session::init::{LspOptions, SemanticTokensList};
use auto_lsp::{define_semantic_token_modifiers, define_semantic_token_types};

// List of semantic token types
// This list is generated by the macro
// and can be reused in the LSP server options.
define_semantic_token_types![standard {
    "function" => FUNCTION,
    "variable" => VARIABLE,
}];

// List of semantic token modifiers
// This list is generated by the macro
// and can be reused in the LSP server options.
define_semantic_token_modifiers![standard {
    "declaration" => DECLARATION,
    "readonly" => READONLY,
}];
```

Once you've defined your token types and modifiers, you can use them to generate semantic tokens in your AST.
The following example shows how to build semantic tokens for a custom type.

```rust
define_semantic_token_types!(standard {
    "Function" => FUNCTION,
});

impl BuildSemanticTokens for MyType {
    fn build_semantic_tokens(&self, doc: &Document, builder: &mut SemanticTokensBuilder) {
        builder.push(
            self.name.read().get_lsp_range(doc),
            TOKEN_TYPES.get_index("Function").unwrap() as u32,
            0,
        );
    }
}
```
